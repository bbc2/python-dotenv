{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-dotenv Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. Getting Started Other Use Cases Load configuration without altering the environment Parse configuration as a stream Load .env files in IPython Command-line Interface File format Multiline values Variable expansion Related Projects Acknowledgements Getting Started pip install python-dotenv If your application takes its configuration from environment variables, like a 12-factor application, launching it in development is not very practical because you have to set those environment variables yourself. To help you with that, you can add Python-dotenv to your application to make it load the configuration from a .env file when it is present (e.g. in development) while remaining configurable via the environment: from dotenv import load_dotenv load_dotenv () # take environment variables from .env. # Code of your application, which uses environment variables (e.g. from `os.environ` or # `os.getenv`) as if they came from the actual environment. By default, load_dotenv doesn't override existing environment variables. To configure the development environment, add a .env in the root directory of your project: . \u251c\u2500\u2500 .env \u2514\u2500\u2500 foo.py The syntax of .env files supported by python-dotenv is similar to that of Bash: # Development settings DOMAIN = example.org ADMIN_EMAIL = admin@ ${ DOMAIN } ROOT_URL = ${ DOMAIN } /app If you use variables in values, ensure they are surrounded with { and } , like ${DOMAIN} , as bare variables such as $DOMAIN are not expanded. You will probably want to add .env to your .gitignore , especially if it contains secrets like a password. See the section \"File format\" below for more information about what you can write in a .env file. Other Use Cases Load configuration without altering the environment The function dotenv_values works more or less the same way as load_dotenv , except it doesn't touch the environment, it just returns a dict with the values parsed from the .env file. from dotenv import dotenv_values config = dotenv_values ( \".env\" ) # config = {\"USER\": \"foo\", \"EMAIL\": \"foo@example.org\"} This notably enables advanced configuration management: import os from dotenv import dotenv_values config = { ** dotenv_values ( \".env.shared\" ), # load shared development variables ** dotenv_values ( \".env.secret\" ), # load sensitive variables ** os . environ , # override loaded values with environment variables } Parse configuration as a stream load_dotenv and dotenv_values accept streams via their stream argument. It is thus possible to load the variables from sources other than the filesystem (e.g. the network). from io import StringIO from dotenv import load_dotenv config = StringIO ( \"USER=foo \\n EMAIL=foo@example.org\" ) load_dotenv ( stream = config ) Load .env files in IPython You can use dotenv in IPython. By default, it will use find_dotenv to search for a .env file: % load_ext dotenv % dotenv You can also specify a path: % dotenv relative / or / absolute / path / to /. env Optional flags: -o to override existing variables. -v for increased verbosity. Command-line Interface A CLI interface dotenv is also included, which helps you manipulate the .env file without manually opening it. $ pip install \"python-dotenv[cli]\" $ dotenv set USER foo $ dotenv set EMAIL foo@example.org $ dotenv list USER = foo EMAIL = foo@example.org $ dotenv run -- python foo.py Run dotenv --help for more information about the options and subcommands. File format The format is not formally specified and still improves over time. That being said, .env files should mostly look like Bash files. Keys can be unquoted or single-quoted. Values can be unquoted, single- or double-quoted. Spaces before and after keys, equal signs, and values are ignored. Values can be followed by a comment. Lines can start with the export directive, which has no effect on their interpretation. Allowed escape sequences: in single-quoted values: \\\\ , \\' in double-quoted values: \\\\ , \\' , \\\" , \\a , \\b , \\f , \\n , \\r , \\t , \\v Multiline values It is possible for single- or double-quoted values to span multiple lines. The following examples are equivalent: FOO = \"first line second line\" FOO = \"first line\\nsecond line\" Variable without a value A variable can have no value: FOO It results in dotenv_values associating that variable name with the value None (e.g. {\"FOO\": None} . load_dotenv , on the other hand, simply ignores such variables. This shouldn't be confused with FOO= , in which case the variable is associated with the empty string. Variable expansion Python-dotenv can interpolate variables using POSIX variable expansion. With load_dotenv(override=True) or dotenv_values() , the value of a variable is the first of the values defined in the following list: Value of that variable in the .env file. Value of that variable in the environment. Default value, if provided. Empty string. With load_dotenv(override=False) , the value of a variable is the first of the values defined in the following list: Value of that variable in the environment. Value of that variable in the .env file. Default value, if provided. Empty string. Related Projects Honcho - For managing Procfile-based applications. django-dotenv django-environ django-environ-2 django-configuration dump-env environs dynaconf Acknowledgements This project is currently maintained by Saurabh Kumar and Bertrand Bonnefoy-Claudet and would not have been possible without the support of these awesome people .","title":"Home"},{"location":"#python-dotenv","text":"Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. Getting Started Other Use Cases Load configuration without altering the environment Parse configuration as a stream Load .env files in IPython Command-line Interface File format Multiline values Variable expansion Related Projects Acknowledgements","title":"python-dotenv"},{"location":"#getting-started","text":"pip install python-dotenv If your application takes its configuration from environment variables, like a 12-factor application, launching it in development is not very practical because you have to set those environment variables yourself. To help you with that, you can add Python-dotenv to your application to make it load the configuration from a .env file when it is present (e.g. in development) while remaining configurable via the environment: from dotenv import load_dotenv load_dotenv () # take environment variables from .env. # Code of your application, which uses environment variables (e.g. from `os.environ` or # `os.getenv`) as if they came from the actual environment. By default, load_dotenv doesn't override existing environment variables. To configure the development environment, add a .env in the root directory of your project: . \u251c\u2500\u2500 .env \u2514\u2500\u2500 foo.py The syntax of .env files supported by python-dotenv is similar to that of Bash: # Development settings DOMAIN = example.org ADMIN_EMAIL = admin@ ${ DOMAIN } ROOT_URL = ${ DOMAIN } /app If you use variables in values, ensure they are surrounded with { and } , like ${DOMAIN} , as bare variables such as $DOMAIN are not expanded. You will probably want to add .env to your .gitignore , especially if it contains secrets like a password. See the section \"File format\" below for more information about what you can write in a .env file.","title":"Getting Started"},{"location":"#other-use-cases","text":"","title":"Other Use Cases"},{"location":"#load-configuration-without-altering-the-environment","text":"The function dotenv_values works more or less the same way as load_dotenv , except it doesn't touch the environment, it just returns a dict with the values parsed from the .env file. from dotenv import dotenv_values config = dotenv_values ( \".env\" ) # config = {\"USER\": \"foo\", \"EMAIL\": \"foo@example.org\"} This notably enables advanced configuration management: import os from dotenv import dotenv_values config = { ** dotenv_values ( \".env.shared\" ), # load shared development variables ** dotenv_values ( \".env.secret\" ), # load sensitive variables ** os . environ , # override loaded values with environment variables }","title":"Load configuration without altering the environment"},{"location":"#parse-configuration-as-a-stream","text":"load_dotenv and dotenv_values accept streams via their stream argument. It is thus possible to load the variables from sources other than the filesystem (e.g. the network). from io import StringIO from dotenv import load_dotenv config = StringIO ( \"USER=foo \\n EMAIL=foo@example.org\" ) load_dotenv ( stream = config )","title":"Parse configuration as a stream"},{"location":"#load-env-files-in-ipython","text":"You can use dotenv in IPython. By default, it will use find_dotenv to search for a .env file: % load_ext dotenv % dotenv You can also specify a path: % dotenv relative / or / absolute / path / to /. env Optional flags: -o to override existing variables. -v for increased verbosity.","title":"Load .env files in IPython"},{"location":"#command-line-interface","text":"A CLI interface dotenv is also included, which helps you manipulate the .env file without manually opening it. $ pip install \"python-dotenv[cli]\" $ dotenv set USER foo $ dotenv set EMAIL foo@example.org $ dotenv list USER = foo EMAIL = foo@example.org $ dotenv run -- python foo.py Run dotenv --help for more information about the options and subcommands.","title":"Command-line Interface"},{"location":"#file-format","text":"The format is not formally specified and still improves over time. That being said, .env files should mostly look like Bash files. Keys can be unquoted or single-quoted. Values can be unquoted, single- or double-quoted. Spaces before and after keys, equal signs, and values are ignored. Values can be followed by a comment. Lines can start with the export directive, which has no effect on their interpretation. Allowed escape sequences: in single-quoted values: \\\\ , \\' in double-quoted values: \\\\ , \\' , \\\" , \\a , \\b , \\f , \\n , \\r , \\t , \\v","title":"File format"},{"location":"#multiline-values","text":"It is possible for single- or double-quoted values to span multiple lines. The following examples are equivalent: FOO = \"first line second line\" FOO = \"first line\\nsecond line\"","title":"Multiline values"},{"location":"#variable-without-a-value","text":"A variable can have no value: FOO It results in dotenv_values associating that variable name with the value None (e.g. {\"FOO\": None} . load_dotenv , on the other hand, simply ignores such variables. This shouldn't be confused with FOO= , in which case the variable is associated with the empty string.","title":"Variable without a value"},{"location":"#variable-expansion","text":"Python-dotenv can interpolate variables using POSIX variable expansion. With load_dotenv(override=True) or dotenv_values() , the value of a variable is the first of the values defined in the following list: Value of that variable in the .env file. Value of that variable in the environment. Default value, if provided. Empty string. With load_dotenv(override=False) , the value of a variable is the first of the values defined in the following list: Value of that variable in the environment. Value of that variable in the .env file. Default value, if provided. Empty string.","title":"Variable expansion"},{"location":"#related-projects","text":"Honcho - For managing Procfile-based applications. django-dotenv django-environ django-environ-2 django-configuration dump-env environs dynaconf","title":"Related Projects"},{"location":"#acknowledgements","text":"This project is currently maintained by Saurabh Kumar and Bertrand Bonnefoy-Claudet and would not have been possible without the support of these awesome people .","title":"Acknowledgements"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 0.20.0 - 2022-03-24 Added Add encoding ( Optional[str] ) parameter to get_key , set_key and unset_key . (#379 by @bbc2 ) Fixed Use dict to specify the entry_points parameter of setuptools.setup (#376 by @mgorny ). Don't build universal wheels (#387 by @bbc2 ). 0.19.2 - 2021-11-11 Fixed In set_key , add missing newline character before new entry if necessary. (#361 by @bbc2 ) 0.19.1 - 2021-08-09 Added Add support for Python 3.10. (#359 by @theskumar ) 0.19.0 - 2021-07-24 Changed Require Python 3.5 or a later version. Python 2 and 3.4 are no longer supported. (#341 by @bbc2 ). Added The dotenv_path argument of set_key and unset_key now has a type of Union[str, os.PathLike] instead of just os.PathLike (#347 by @bbc2 ). The stream argument of load_dotenv and dotenv_values can now be a text stream ( IO[str] ), which includes values like io.StringIO(\"foo\") and open(\"file.env\", \"r\") (#348 by @bbc2 ). 0.18.0 - 2021-06-20 Changed Raise ValueError if quote_mode isn't one of always , auto or never in set_key (#330 by @bbc2 ). When writing a value to a .env file with set_key or dotenv set <key> <value> (#330 by @bbc2 ): Use single quotes instead of double quotes. Don't strip surrounding quotes. In auto mode, don't add quotes if the value is only made of alphanumeric characters (as determined by string.isalnum ). 0.17.1 - 2021-04-29 Fixed Fixed tests for build environments relying on PYTHONPATH (#318 by @befeleme ). 0.17.0 - 2021-04-02 Changed Make dotenv get <key> only show the value, not key=value (#313 by @bbc2 ). Added Add --override / --no-override option to dotenv run (#312 by @zueve and @bbc2 ). 0.16.0 - 2021-03-27 Changed The default value of the encoding parameter for load_dotenv and dotenv_values is now \"utf-8\" instead of None (#306 by @bbc2 ). Fix resolution order in variable expansion with override=False (#287 by @bbc2 ). 0.15.0 - 2020-10-28 Added Add --export option to set to make it prepend the binding with export (#270 by @jadutter ). Changed Make set command create the .env file in the current directory if no .env file was found (#270 by @jadutter ). Fixed Fix potentially empty expanded value for duplicate key (#260 by @bbc2 ). Fix import error on Python 3.5.0 and 3.5.1 (#267 by @gongqingkui ). Fix parsing of unquoted values containing several adjacent space or tab characters (#277 by @bbc2 , review by @x-yuri ). 0.14.0 - 2020-07-03 Changed Privilege definition in file over the environment in variable expansion (#256 by @elbehery95 ). Fixed Improve error message for when file isn't found (#245 by @snobu ). Use HTTPS URL in package meta data (#251 by @ekohl ). 0.13.0 - 2020-04-16 Added Add support for a Bash-like default value in variable expansion (#248 by @bbc2 ). 0.12.0 - 2020-02-28 Changed Use current working directory to find .env when bundled by PyInstaller (#213 by @gergelyk ). Fixed Fix escaping of quoted values written by set_key (#236 by @bbc2 ). Fix dotenv run crashing on environment variables without values (#237 by @yannham ). Remove warning when last line is empty (#238 by @bbc2 ). 0.11.0 - 2020-02-07 Added Add interpolate argument to load_dotenv and dotenv_values to disable interpolation (#232 by @ulyssessouza ). Changed Use logging instead of warnings (#231 by @bbc2 ). Fixed Fix installation in non-UTF-8 environments (#225 by @altendky ). Fix PyPI classifiers (#228 by @bbc2 ). 0.10.5 - 2020-01-19 Fixed Fix handling of malformed lines and lines without a value (#222 by @bbc2 ): Don't print warning when key has no value. Reject more malformed lines (e.g. \"A: B\", \"a='b',c\"). Fix handling of lines with just a comment (#224 by @bbc2 ). 0.10.4 - 2020-01-17 Added Make typing optional (#179 by @techalchemy ). Print a warning on malformed line (#211 by @bbc2 ). Support keys without a value (#220 by @ulyssessouza ). 0.10.3 Improve interactive mode detection ( @andrewsmith )( #183 ). Refactor parser to fix parsing inconsistencies ( @bbc2 )( #170 ). Interpret escapes as control characters only in double-quoted strings. Interpret # as start of comment only if preceded by whitespace. 0.10.2 Add type hints and expose them to users ( @qnighy )( #172 ) load_dotenv and dotenv_values now accept an encoding parameter, defaults to None ( @theskumar )( @earlbread )([#161]) Fix str / unicode inconsistency in Python 2: values are always str now. ( @bbc2 )( #121 ) Fix Unicode error in Python 2, introduced in 0.10.0. ( @bbc2 )( #176 ) 0.10.1 Fix parsing of variable without a value ( @asyncee )( @bbc2 )( #158 ) 0.10.0 Add support for UTF-8 in unquoted values ( @bbc2 )( #148 ) Add support for trailing comments ( @bbc2 )( #148 ) Add backslashes support in values ( @bbc2 )( #148 ) Add support for newlines in values ( @bbc2 )( #148 ) Force environment variables to str with Python2 on Windows ( @greyli ) Drop Python 3.3 support ( @greyli ) Fix stderr/-out/-in redirection ( @venthur ) 0.9.0 Add --version parameter to cli ( @venthur ) Enable loading from current directory ( @cjauvin ) Add 'dotenv run' command for calling arbitrary shell script with .env ( @venthur ) 0.8.1 Add tests for docs ( @Flimm ) Make 'cli' support optional. Use pip install python-dotenv[cli] . ( @theskumar ) 0.8.0 set_key and unset_key only modified the affected file instead of parsing and re-writing file, this causes comments and other file entact as it is. Add support for export prefix in the line. Internal refractoring ( @theskumar ) Allow load_dotenv and dotenv_values to work with StringIO()) ( @alanjds )( @theskumar )( #78 ) 0.7.1 Remove hard dependency on iPython ( @theskumar ) 0.7.0 Add support to override system environment variable via .env. ( @milonimrod ) ( #63 ) Disable \".env not found\" warning by default ( @maxkoryukov ) ( #57 ) 0.6.5 Add support for special characters \\ . ( @pjona ) ( #60 ) 0.6.4 Fix issue with single quotes ( @Flimm ) ( #52 ) 0.6.3 Handle unicode exception in setup.py ( #46 ) 0.6.2 Fix dotenv list command ( @ticosax ) Add iPython Support ( @tillahoffmann ) 0.6.0 Drop support for Python 2.6 Handle escaped characters and newlines in quoted values. (Thanks @iameugenejo ) Remove any spaces around unquoted key/value. (Thanks @paulochf ) Added POSIX variable expansion. (Thanks @hugochinchilla ) 0.5.1 Fix find_dotenv - it now start search from the file where this function is called from. 0.5.0 Add find_dotenv method that will try to find a .env file. (Thanks @isms ) 0.4.0 cli: Added -q/--quote option to control the behaviour of quotes around values in .env . (Thanks @hugochinchilla ). Improved test coverage.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#0200-2022-03-24","text":"","title":"0.20.0 - 2022-03-24"},{"location":"CHANGELOG/#added","text":"Add encoding ( Optional[str] ) parameter to get_key , set_key and unset_key . (#379 by @bbc2 )","title":"Added"},{"location":"CHANGELOG/#fixed","text":"Use dict to specify the entry_points parameter of setuptools.setup (#376 by @mgorny ). Don't build universal wheels (#387 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0192-2021-11-11","text":"","title":"0.19.2 - 2021-11-11"},{"location":"CHANGELOG/#fixed_1","text":"In set_key , add missing newline character before new entry if necessary. (#361 by @bbc2 )","title":"Fixed"},{"location":"CHANGELOG/#0191-2021-08-09","text":"","title":"0.19.1 - 2021-08-09"},{"location":"CHANGELOG/#added_1","text":"Add support for Python 3.10. (#359 by @theskumar )","title":"Added"},{"location":"CHANGELOG/#0190-2021-07-24","text":"","title":"0.19.0 - 2021-07-24"},{"location":"CHANGELOG/#changed","text":"Require Python 3.5 or a later version. Python 2 and 3.4 are no longer supported. (#341 by @bbc2 ).","title":"Changed"},{"location":"CHANGELOG/#added_2","text":"The dotenv_path argument of set_key and unset_key now has a type of Union[str, os.PathLike] instead of just os.PathLike (#347 by @bbc2 ). The stream argument of load_dotenv and dotenv_values can now be a text stream ( IO[str] ), which includes values like io.StringIO(\"foo\") and open(\"file.env\", \"r\") (#348 by @bbc2 ).","title":"Added"},{"location":"CHANGELOG/#0180-2021-06-20","text":"","title":"0.18.0 - 2021-06-20"},{"location":"CHANGELOG/#changed_1","text":"Raise ValueError if quote_mode isn't one of always , auto or never in set_key (#330 by @bbc2 ). When writing a value to a .env file with set_key or dotenv set <key> <value> (#330 by @bbc2 ): Use single quotes instead of double quotes. Don't strip surrounding quotes. In auto mode, don't add quotes if the value is only made of alphanumeric characters (as determined by string.isalnum ).","title":"Changed"},{"location":"CHANGELOG/#0171-2021-04-29","text":"","title":"0.17.1 - 2021-04-29"},{"location":"CHANGELOG/#fixed_2","text":"Fixed tests for build environments relying on PYTHONPATH (#318 by @befeleme ).","title":"Fixed"},{"location":"CHANGELOG/#0170-2021-04-02","text":"","title":"0.17.0 - 2021-04-02"},{"location":"CHANGELOG/#changed_2","text":"Make dotenv get <key> only show the value, not key=value (#313 by @bbc2 ).","title":"Changed"},{"location":"CHANGELOG/#added_3","text":"Add --override / --no-override option to dotenv run (#312 by @zueve and @bbc2 ).","title":"Added"},{"location":"CHANGELOG/#0160-2021-03-27","text":"","title":"0.16.0 - 2021-03-27"},{"location":"CHANGELOG/#changed_3","text":"The default value of the encoding parameter for load_dotenv and dotenv_values is now \"utf-8\" instead of None (#306 by @bbc2 ). Fix resolution order in variable expansion with override=False (#287 by @bbc2 ).","title":"Changed"},{"location":"CHANGELOG/#0150-2020-10-28","text":"","title":"0.15.0 - 2020-10-28"},{"location":"CHANGELOG/#added_4","text":"Add --export option to set to make it prepend the binding with export (#270 by @jadutter ).","title":"Added"},{"location":"CHANGELOG/#changed_4","text":"Make set command create the .env file in the current directory if no .env file was found (#270 by @jadutter ).","title":"Changed"},{"location":"CHANGELOG/#fixed_3","text":"Fix potentially empty expanded value for duplicate key (#260 by @bbc2 ). Fix import error on Python 3.5.0 and 3.5.1 (#267 by @gongqingkui ). Fix parsing of unquoted values containing several adjacent space or tab characters (#277 by @bbc2 , review by @x-yuri ).","title":"Fixed"},{"location":"CHANGELOG/#0140-2020-07-03","text":"","title":"0.14.0 - 2020-07-03"},{"location":"CHANGELOG/#changed_5","text":"Privilege definition in file over the environment in variable expansion (#256 by @elbehery95 ).","title":"Changed"},{"location":"CHANGELOG/#fixed_4","text":"Improve error message for when file isn't found (#245 by @snobu ). Use HTTPS URL in package meta data (#251 by @ekohl ).","title":"Fixed"},{"location":"CHANGELOG/#0130-2020-04-16","text":"","title":"0.13.0 - 2020-04-16"},{"location":"CHANGELOG/#added_5","text":"Add support for a Bash-like default value in variable expansion (#248 by @bbc2 ).","title":"Added"},{"location":"CHANGELOG/#0120-2020-02-28","text":"","title":"0.12.0 - 2020-02-28"},{"location":"CHANGELOG/#changed_6","text":"Use current working directory to find .env when bundled by PyInstaller (#213 by @gergelyk ).","title":"Changed"},{"location":"CHANGELOG/#fixed_5","text":"Fix escaping of quoted values written by set_key (#236 by @bbc2 ). Fix dotenv run crashing on environment variables without values (#237 by @yannham ). Remove warning when last line is empty (#238 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0110-2020-02-07","text":"","title":"0.11.0 - 2020-02-07"},{"location":"CHANGELOG/#added_6","text":"Add interpolate argument to load_dotenv and dotenv_values to disable interpolation (#232 by @ulyssessouza ).","title":"Added"},{"location":"CHANGELOG/#changed_7","text":"Use logging instead of warnings (#231 by @bbc2 ).","title":"Changed"},{"location":"CHANGELOG/#fixed_6","text":"Fix installation in non-UTF-8 environments (#225 by @altendky ). Fix PyPI classifiers (#228 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0105-2020-01-19","text":"","title":"0.10.5 - 2020-01-19"},{"location":"CHANGELOG/#fixed_7","text":"Fix handling of malformed lines and lines without a value (#222 by @bbc2 ): Don't print warning when key has no value. Reject more malformed lines (e.g. \"A: B\", \"a='b',c\"). Fix handling of lines with just a comment (#224 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0104-2020-01-17","text":"","title":"0.10.4 - 2020-01-17"},{"location":"CHANGELOG/#added_7","text":"Make typing optional (#179 by @techalchemy ). Print a warning on malformed line (#211 by @bbc2 ). Support keys without a value (#220 by @ulyssessouza ).","title":"Added"},{"location":"CHANGELOG/#0103","text":"Improve interactive mode detection ( @andrewsmith )( #183 ). Refactor parser to fix parsing inconsistencies ( @bbc2 )( #170 ). Interpret escapes as control characters only in double-quoted strings. Interpret # as start of comment only if preceded by whitespace.","title":"0.10.3"},{"location":"CHANGELOG/#0102","text":"Add type hints and expose them to users ( @qnighy )( #172 ) load_dotenv and dotenv_values now accept an encoding parameter, defaults to None ( @theskumar )( @earlbread )([#161]) Fix str / unicode inconsistency in Python 2: values are always str now. ( @bbc2 )( #121 ) Fix Unicode error in Python 2, introduced in 0.10.0. ( @bbc2 )( #176 )","title":"0.10.2"},{"location":"CHANGELOG/#0101","text":"Fix parsing of variable without a value ( @asyncee )( @bbc2 )( #158 )","title":"0.10.1"},{"location":"CHANGELOG/#0100","text":"Add support for UTF-8 in unquoted values ( @bbc2 )( #148 ) Add support for trailing comments ( @bbc2 )( #148 ) Add backslashes support in values ( @bbc2 )( #148 ) Add support for newlines in values ( @bbc2 )( #148 ) Force environment variables to str with Python2 on Windows ( @greyli ) Drop Python 3.3 support ( @greyli ) Fix stderr/-out/-in redirection ( @venthur )","title":"0.10.0"},{"location":"CHANGELOG/#090","text":"Add --version parameter to cli ( @venthur ) Enable loading from current directory ( @cjauvin ) Add 'dotenv run' command for calling arbitrary shell script with .env ( @venthur )","title":"0.9.0"},{"location":"CHANGELOG/#081","text":"Add tests for docs ( @Flimm ) Make 'cli' support optional. Use pip install python-dotenv[cli] . ( @theskumar )","title":"0.8.1"},{"location":"CHANGELOG/#080","text":"set_key and unset_key only modified the affected file instead of parsing and re-writing file, this causes comments and other file entact as it is. Add support for export prefix in the line. Internal refractoring ( @theskumar ) Allow load_dotenv and dotenv_values to work with StringIO()) ( @alanjds )( @theskumar )( #78 )","title":"0.8.0"},{"location":"CHANGELOG/#071","text":"Remove hard dependency on iPython ( @theskumar )","title":"0.7.1"},{"location":"CHANGELOG/#070","text":"Add support to override system environment variable via .env. ( @milonimrod ) ( #63 ) Disable \".env not found\" warning by default ( @maxkoryukov ) ( #57 )","title":"0.7.0"},{"location":"CHANGELOG/#065","text":"Add support for special characters \\ . ( @pjona ) ( #60 )","title":"0.6.5"},{"location":"CHANGELOG/#064","text":"Fix issue with single quotes ( @Flimm ) ( #52 )","title":"0.6.4"},{"location":"CHANGELOG/#063","text":"Handle unicode exception in setup.py ( #46 )","title":"0.6.3"},{"location":"CHANGELOG/#062","text":"Fix dotenv list command ( @ticosax ) Add iPython Support ( @tillahoffmann )","title":"0.6.2"},{"location":"CHANGELOG/#060","text":"Drop support for Python 2.6 Handle escaped characters and newlines in quoted values. (Thanks @iameugenejo ) Remove any spaces around unquoted key/value. (Thanks @paulochf ) Added POSIX variable expansion. (Thanks @hugochinchilla )","title":"0.6.0"},{"location":"CHANGELOG/#051","text":"Fix find_dotenv - it now start search from the file where this function is called from.","title":"0.5.1"},{"location":"CHANGELOG/#050","text":"Add find_dotenv method that will try to find a .env file. (Thanks @isms )","title":"0.5.0"},{"location":"CHANGELOG/#040","text":"cli: Added -q/--quote option to control the behaviour of quotes around values in .env . (Thanks @hugochinchilla ). Improved test coverage.","title":"0.4.0"},{"location":"CONTRIBUTING/","text":"Contributing All the contributions are welcome! Please open an issue or send us a pull request. Executing the tests: $ pip install -r requirements.txt $ pip install -e . $ flake8 $ pytest or with tox installed: $ tox","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All the contributions are welcome! Please open an issue or send us a pull request. Executing the tests: $ pip install -r requirements.txt $ pip install -e . $ flake8 $ pytest or with tox installed: $ tox","title":"Contributing"},{"location":"reference/dotenv/","text":"Module dotenv None None View Source from typing import Any , Optional from .main import ( dotenv_values , find_dotenv , get_key , load_dotenv , set_key , unset_key ) def load_ipython_extension ( ipython : Any ) -> None : from .ipython import load_ipython_extension load_ipython_extension ( ipython ) def get_cli_string ( path : Optional [ str ] = None , action : Optional [ str ] = None , key : Optional [ str ] = None , value : Optional [ str ] = None , quote : Optional [ str ] = None , ): \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s ' % quote ) if path : command . append ( '-f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\" %s \"' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () __all__ = [ 'get_cli_string' , 'load_dotenv' , 'dotenv_values' , 'get_key' , 'set_key' , 'unset_key' , 'find_dotenv' , 'load_ipython_extension' ] Sub-modules dotenv.cli dotenv.ipython dotenv.main dotenv.parser dotenv.variables dotenv.version Functions dotenv_values def dotenv_values ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> Dict [ str , Optional [ str ]] Parse a .env file and return its content as a dict. The returned dict will have None values for keys without values in the .env file. For example, foo=bar results in {\"foo\": \"bar\"} whereas foo alone results in {\"foo\": None} Parameters: dotenv_path : absolute or relative path to the .env file. stream : StringIO object with .env content, used if dotenv_path is None . verbose : whether to output a warning if the .env file is missing. Defaults to False . encoding : encoding to be used to read the file. Defaults to \"utf-8\" . If both dotenv_path and stream are None , find_dotenv() is used to find the .env file. View Source def dotenv_values ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> Dict [ str , Optional [ str ]] : \" \"\" Parse a .env file and return its content as a dict. The returned dict will have `None` values for keys without values in the .env file. For example, `foo=bar` results in `{\" foo \": \" bar \"}` whereas `foo` alone results in `{\" foo \": None}` Parameters: - `dotenv_path`: absolute or relative path to the .env file. - `stream`: `StringIO` object with .env content, used if `dotenv_path` is `None`. - `verbose`: whether to output a warning if the .env file is missing. Defaults to `False`. - `encoding`: encoding to be used to read the file. Defaults to `\" utf - 8 \"`. If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the .env file. \"\" \" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () return DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = True , encoding = encoding , ). dict () find_dotenv def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False ) -> str Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False , ) -> str : \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive () : \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ) : # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ) : check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ) : return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return '' get_cli_string def get_cli_string ( path : Optional [ str ] = None , action : Optional [ str ] = None , key : Optional [ str ] = None , value : Optional [ str ] = None , quote : Optional [ str ] = None ) Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a local or run command. View Source def get_cli_string ( path : Optional [ str ] = None , action : Optional [ str ] = None , key : Optional [ str ] = None , value : Optional [ str ] = None , quote : Optional [ str ] = None , ) : \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s' % quote ) if path : command . append ( '-f %s' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\"%s\"' % value ) else : command . append ( value ) return ' ' . join ( command ). strip () get_key def get_key ( dotenv_path : Union [ str , os . PathLike ], key_to_get : str , encoding : Optional [ str ] = 'utf-8' ) -> Optional [ str ] Get the value of a given key from the given .env. Returns None if the key isn't found or doesn't have a value. View Source def get_key ( dotenv_path : Union [ str, _PathLike ] , key_to_get : str , encoding : Optional [ str ] = \"utf-8\" , ) -> Optional [ str ] : \"\"\" Get the value of a given key from the given .env. Returns `None` if the key isn't found or doesn't have a value. \"\"\" return DotEnv ( dotenv_path , verbose = True , encoding = encoding ). get ( key_to_get ) load_dotenv def load_dotenv ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> bool Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : Text stream (such as io.StringIO ) with .env content, used if dotenv_path is None . verbose : whether to output a warning the .env file is missing. Defaults to False . override : whether to override the system environment variables with the variables in .env file. Defaults to False . encoding : encoding to be used to read the file. If both dotenv_path and stream , find_dotenv() is used to find the .env file. View Source def load_dotenv ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> bool : \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: Text stream (such as `io.StringIO`) with .env content, used if `dotenv_path` is `None`. - *verbose*: whether to output a warning the .env file is missing. Defaults to `False`. - *override*: whether to override the system environment variables with the variables in `.env` file. Defaults to `False`. - *encoding*: encoding to be used to read the file. If both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () dotenv = DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = override , encoding = encoding , ) return dotenv . set_as_environment_variables () load_ipython_extension def load_ipython_extension ( ipython : Any ) -> None View Source def load_ipython_extension ( ipython : Any ) -> None : from .ipython import load_ipython_extension load_ipython_extension ( ipython ) set_key def set_key ( dotenv_path : Union [ str , os . PathLike ], key_to_set : str , value_to_set : str , quote_mode : str = 'always' , export : bool = False , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str , str ] Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path : Union [ str, _PathLike ] , key_to_set : str , value_to_set : str , quote_mode : str = \"always\" , export : bool = False , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str , str ]: \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" if quote_mode not in ( \"always\" , \"auto\" , \"never\" ) : raise ValueError ( \"Unknown quote_mode: {}\" . format ( quote_mode )) quote = ( quote_mode == \"always\" or ( quote_mode == \"auto\" and not value_to_set . isalnum ()) ) if quote : value_out = \"'{}'\" . format ( value_to_set . replace ( \"'\" , \"\\\\'\" )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : replaced = False missing_newline = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) missing_newline = not mapping . original . string . endswith ( \"\\n\" ) if not replaced : if missing_newline : dest . write ( \"\\n\" ) dest . write ( line_out ) return True , key_to_set , value_to_set unset_key def unset_key ( dotenv_path : Union [ str , os . PathLike ], key_to_unset : str , quote_mode : str = 'always' , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str ] Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path : Union [ str, _PathLike ] , key_to_unset : str , quote_mode : str = \"always\" , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str ]: \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset","title":"Index"},{"location":"reference/dotenv/#module-dotenv","text":"None None View Source from typing import Any , Optional from .main import ( dotenv_values , find_dotenv , get_key , load_dotenv , set_key , unset_key ) def load_ipython_extension ( ipython : Any ) -> None : from .ipython import load_ipython_extension load_ipython_extension ( ipython ) def get_cli_string ( path : Optional [ str ] = None , action : Optional [ str ] = None , key : Optional [ str ] = None , value : Optional [ str ] = None , quote : Optional [ str ] = None , ): \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s ' % quote ) if path : command . append ( '-f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\" %s \"' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () __all__ = [ 'get_cli_string' , 'load_dotenv' , 'dotenv_values' , 'get_key' , 'set_key' , 'unset_key' , 'find_dotenv' , 'load_ipython_extension' ]","title":"Module dotenv"},{"location":"reference/dotenv/#sub-modules","text":"dotenv.cli dotenv.ipython dotenv.main dotenv.parser dotenv.variables dotenv.version","title":"Sub-modules"},{"location":"reference/dotenv/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/#dotenv_values","text":"def dotenv_values ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> Dict [ str , Optional [ str ]] Parse a .env file and return its content as a dict. The returned dict will have None values for keys without values in the .env file. For example, foo=bar results in {\"foo\": \"bar\"} whereas foo alone results in {\"foo\": None} Parameters: dotenv_path : absolute or relative path to the .env file. stream : StringIO object with .env content, used if dotenv_path is None . verbose : whether to output a warning if the .env file is missing. Defaults to False . encoding : encoding to be used to read the file. Defaults to \"utf-8\" . If both dotenv_path and stream are None , find_dotenv() is used to find the .env file. View Source def dotenv_values ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> Dict [ str , Optional [ str ]] : \" \"\" Parse a .env file and return its content as a dict. The returned dict will have `None` values for keys without values in the .env file. For example, `foo=bar` results in `{\" foo \": \" bar \"}` whereas `foo` alone results in `{\" foo \": None}` Parameters: - `dotenv_path`: absolute or relative path to the .env file. - `stream`: `StringIO` object with .env content, used if `dotenv_path` is `None`. - `verbose`: whether to output a warning if the .env file is missing. Defaults to `False`. - `encoding`: encoding to be used to read the file. Defaults to `\" utf - 8 \"`. If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the .env file. \"\" \" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () return DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = True , encoding = encoding , ). dict ()","title":"dotenv_values"},{"location":"reference/dotenv/#find_dotenv","text":"def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False ) -> str Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False , ) -> str : \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive () : \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ) : # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ) : check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ) : return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return ''","title":"find_dotenv"},{"location":"reference/dotenv/#get_cli_string","text":"def get_cli_string ( path : Optional [ str ] = None , action : Optional [ str ] = None , key : Optional [ str ] = None , value : Optional [ str ] = None , quote : Optional [ str ] = None ) Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a local or run command. View Source def get_cli_string ( path : Optional [ str ] = None , action : Optional [ str ] = None , key : Optional [ str ] = None , value : Optional [ str ] = None , quote : Optional [ str ] = None , ) : \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s' % quote ) if path : command . append ( '-f %s' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\"%s\"' % value ) else : command . append ( value ) return ' ' . join ( command ). strip ()","title":"get_cli_string"},{"location":"reference/dotenv/#get_key","text":"def get_key ( dotenv_path : Union [ str , os . PathLike ], key_to_get : str , encoding : Optional [ str ] = 'utf-8' ) -> Optional [ str ] Get the value of a given key from the given .env. Returns None if the key isn't found or doesn't have a value. View Source def get_key ( dotenv_path : Union [ str, _PathLike ] , key_to_get : str , encoding : Optional [ str ] = \"utf-8\" , ) -> Optional [ str ] : \"\"\" Get the value of a given key from the given .env. Returns `None` if the key isn't found or doesn't have a value. \"\"\" return DotEnv ( dotenv_path , verbose = True , encoding = encoding ). get ( key_to_get )","title":"get_key"},{"location":"reference/dotenv/#load_dotenv","text":"def load_dotenv ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> bool Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : Text stream (such as io.StringIO ) with .env content, used if dotenv_path is None . verbose : whether to output a warning the .env file is missing. Defaults to False . override : whether to override the system environment variables with the variables in .env file. Defaults to False . encoding : encoding to be used to read the file. If both dotenv_path and stream , find_dotenv() is used to find the .env file. View Source def load_dotenv ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> bool : \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: Text stream (such as `io.StringIO`) with .env content, used if `dotenv_path` is `None`. - *verbose*: whether to output a warning the .env file is missing. Defaults to `False`. - *override*: whether to override the system environment variables with the variables in `.env` file. Defaults to `False`. - *encoding*: encoding to be used to read the file. If both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () dotenv = DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = override , encoding = encoding , ) return dotenv . set_as_environment_variables ()","title":"load_dotenv"},{"location":"reference/dotenv/#load_ipython_extension","text":"def load_ipython_extension ( ipython : Any ) -> None View Source def load_ipython_extension ( ipython : Any ) -> None : from .ipython import load_ipython_extension load_ipython_extension ( ipython )","title":"load_ipython_extension"},{"location":"reference/dotenv/#set_key","text":"def set_key ( dotenv_path : Union [ str , os . PathLike ], key_to_set : str , value_to_set : str , quote_mode : str = 'always' , export : bool = False , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str , str ] Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path : Union [ str, _PathLike ] , key_to_set : str , value_to_set : str , quote_mode : str = \"always\" , export : bool = False , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str , str ]: \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" if quote_mode not in ( \"always\" , \"auto\" , \"never\" ) : raise ValueError ( \"Unknown quote_mode: {}\" . format ( quote_mode )) quote = ( quote_mode == \"always\" or ( quote_mode == \"auto\" and not value_to_set . isalnum ()) ) if quote : value_out = \"'{}'\" . format ( value_to_set . replace ( \"'\" , \"\\\\'\" )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : replaced = False missing_newline = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) missing_newline = not mapping . original . string . endswith ( \"\\n\" ) if not replaced : if missing_newline : dest . write ( \"\\n\" ) dest . write ( line_out ) return True , key_to_set , value_to_set","title":"set_key"},{"location":"reference/dotenv/#unset_key","text":"def unset_key ( dotenv_path : Union [ str , os . PathLike ], key_to_unset : str , quote_mode : str = 'always' , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str ] Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path : Union [ str, _PathLike ] , key_to_unset : str , quote_mode : str = \"always\" , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str ]: \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset","title":"unset_key"},{"location":"reference/dotenv/cli/","text":"Module dotenv.cli None None View Source import os import sys from subprocess import Popen from typing import Any , Dict , List try : import click except ImportError : sys . stderr . write ( 'It seems python-dotenv is not installed with cli option. \\n ' 'Run pip install \"python-dotenv[cli]\" to fix this.' ) sys . exit ( 1 ) from .main import dotenv_values , get_key , set_key , unset_key from .version import __version__ @click . group () @click . option ( '-f' , '--file' , default = os . path . join ( os . getcwd (), '.env' ), type = click . Path ( file_okay = True ), help = \"Location of the .env file, defaults to .env file in current working directory.\" ) @click . option ( '-q' , '--quote' , default = 'always' , type = click . Choice ([ 'always' , 'never' , 'auto' ]), help = \"Whether to quote or not the variable values. Default mode is always. This does not affect parsing.\" ) @click . option ( '-e' , '--export' , default = False , type = click . BOOL , help = \"Whether to write the dot file as an executable bash script.\" ) @click . version_option ( version = __version__ ) @click . pass_context def cli ( ctx : click . Context , file : Any , quote : Any , export : Any ) -> None : '''This script is used to set, get or unset values from a .env file.''' ctx . obj = {} ctx . obj [ 'QUOTE' ] = quote ctx . obj [ 'EXPORT' ] = export ctx . obj [ 'FILE' ] = file @cli . command () @click . pass_context def list ( ctx : click . Context ) -> None : '''Display all the stored key/value.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = dotenv_values ( file ) for k , v in dotenv_as_dict . items (): click . echo ( ' %s = %s ' % ( k , v )) @cli . command () @click . pass_context @click . argument ( 'key' , required = True ) @click . argument ( 'value' , required = True ) def set ( ctx : click . Context , key : Any , value : Any ) -> None : '''Store the given key/value.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] export = ctx . obj [ 'EXPORT' ] success , key , value = set_key ( file , key , value , quote , export ) if success : click . echo ( ' %s = %s ' % ( key , value )) else : exit ( 1 ) @cli . command () @click . pass_context @click . argument ( 'key' , required = True ) def get ( ctx : click . Context , key : Any ) -> None : '''Retrieve the value for the given key.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) stored_value = get_key ( file , key ) if stored_value : click . echo ( stored_value ) else : exit ( 1 ) @cli . command () @click . pass_context @click . argument ( 'key' , required = True ) def unset ( ctx : click . Context , key : Any ) -> None : '''Removes the given key.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] success , key = unset_key ( file , key , quote ) if success : click . echo ( \"Successfully removed %s \" % key ) else : exit ( 1 ) @cli . command ( context_settings = { 'ignore_unknown_options' : True }) @click . pass_context @click . option ( \"--override/--no-override\" , default = True , help = \"Override variables from the environment file with those from the .env file.\" , ) @click . argument ( 'commandline' , nargs =- 1 , type = click . UNPROCESSED ) def run ( ctx : click . Context , override : bool , commandline : List [ str ]) -> None : \"\"\"Run command with environment variables present.\"\"\" file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Invalid value for \\' -f \\' \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = { k : v for ( k , v ) in dotenv_values ( file ) . items () if v is not None and ( override or k not in os . environ ) } if not commandline : click . echo ( 'No command given.' ) exit ( 1 ) ret = run_command ( commandline , dotenv_as_dict ) exit ( ret ) def run_command ( command : List [ str ], env : Dict [ str , str ]) -> int : \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode if __name__ == \"__main__\" : cli () Functions run_command def run_command ( command : List [ str ], env : Dict [ str , str ] ) -> int Run command in sub process. Runs the command in a sub process with the variables from env added in the current environment variables. Parameters: Name Type Description Default command List[str] The command and it's parameters None env Dict The additional environment variables None Returns: Type Description int The return code of the command View Source def run_command ( command : List [ str ], env : Dict [ str , str ]) -> int : \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode","title":"CLI"},{"location":"reference/dotenv/cli/#module-dotenvcli","text":"None None View Source import os import sys from subprocess import Popen from typing import Any , Dict , List try : import click except ImportError : sys . stderr . write ( 'It seems python-dotenv is not installed with cli option. \\n ' 'Run pip install \"python-dotenv[cli]\" to fix this.' ) sys . exit ( 1 ) from .main import dotenv_values , get_key , set_key , unset_key from .version import __version__ @click . group () @click . option ( '-f' , '--file' , default = os . path . join ( os . getcwd (), '.env' ), type = click . Path ( file_okay = True ), help = \"Location of the .env file, defaults to .env file in current working directory.\" ) @click . option ( '-q' , '--quote' , default = 'always' , type = click . Choice ([ 'always' , 'never' , 'auto' ]), help = \"Whether to quote or not the variable values. Default mode is always. This does not affect parsing.\" ) @click . option ( '-e' , '--export' , default = False , type = click . BOOL , help = \"Whether to write the dot file as an executable bash script.\" ) @click . version_option ( version = __version__ ) @click . pass_context def cli ( ctx : click . Context , file : Any , quote : Any , export : Any ) -> None : '''This script is used to set, get or unset values from a .env file.''' ctx . obj = {} ctx . obj [ 'QUOTE' ] = quote ctx . obj [ 'EXPORT' ] = export ctx . obj [ 'FILE' ] = file @cli . command () @click . pass_context def list ( ctx : click . Context ) -> None : '''Display all the stored key/value.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = dotenv_values ( file ) for k , v in dotenv_as_dict . items (): click . echo ( ' %s = %s ' % ( k , v )) @cli . command () @click . pass_context @click . argument ( 'key' , required = True ) @click . argument ( 'value' , required = True ) def set ( ctx : click . Context , key : Any , value : Any ) -> None : '''Store the given key/value.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] export = ctx . obj [ 'EXPORT' ] success , key , value = set_key ( file , key , value , quote , export ) if success : click . echo ( ' %s = %s ' % ( key , value )) else : exit ( 1 ) @cli . command () @click . pass_context @click . argument ( 'key' , required = True ) def get ( ctx : click . Context , key : Any ) -> None : '''Retrieve the value for the given key.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) stored_value = get_key ( file , key ) if stored_value : click . echo ( stored_value ) else : exit ( 1 ) @cli . command () @click . pass_context @click . argument ( 'key' , required = True ) def unset ( ctx : click . Context , key : Any ) -> None : '''Removes the given key.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] success , key = unset_key ( file , key , quote ) if success : click . echo ( \"Successfully removed %s \" % key ) else : exit ( 1 ) @cli . command ( context_settings = { 'ignore_unknown_options' : True }) @click . pass_context @click . option ( \"--override/--no-override\" , default = True , help = \"Override variables from the environment file with those from the .env file.\" , ) @click . argument ( 'commandline' , nargs =- 1 , type = click . UNPROCESSED ) def run ( ctx : click . Context , override : bool , commandline : List [ str ]) -> None : \"\"\"Run command with environment variables present.\"\"\" file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Invalid value for \\' -f \\' \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = { k : v for ( k , v ) in dotenv_values ( file ) . items () if v is not None and ( override or k not in os . environ ) } if not commandline : click . echo ( 'No command given.' ) exit ( 1 ) ret = run_command ( commandline , dotenv_as_dict ) exit ( ret ) def run_command ( command : List [ str ], env : Dict [ str , str ]) -> int : \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode if __name__ == \"__main__\" : cli ()","title":"Module dotenv.cli"},{"location":"reference/dotenv/cli/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/cli/#run_command","text":"def run_command ( command : List [ str ], env : Dict [ str , str ] ) -> int Run command in sub process. Runs the command in a sub process with the variables from env added in the current environment variables. Parameters: Name Type Description Default command List[str] The command and it's parameters None env Dict The additional environment variables None Returns: Type Description int The return code of the command View Source def run_command ( command : List [ str ], env : Dict [ str , str ]) -> int : \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode","title":"run_command"},{"location":"reference/dotenv/ipython/","text":"Module dotenv.ipython None None View Source from IPython.core.magic import Magics , line_magic , magics_class # type: ignore from IPython.core.magic_arguments import ( argument , magic_arguments , # type: ignore parse_argstring ) # type: ignore from .main import find_dotenv , load_dotenv @magics_class class IPythonDotEnv ( Magics ): @magic_arguments () @argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv ) Functions load_ipython_extension def load_ipython_extension ( ipython ) Register the %dotenv magic. View Source def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv ) Classes IPythonDotEnv class IPythonDotEnv ( shell = None , ** kwargs ) View Source @ magics_class class IPythonDotEnv ( Magics ): @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) Ancestors (in MRO) IPython.core.magic.Magics traitlets.config.configurable.Configurable traitlets.traitlets.HasTraits traitlets.traitlets.HasDescriptors Class variables config magics options_table parent registered shell Static methods class_config_rst_doc def class_config_rst_doc ( ) Generate rST documentation for this class' config options. Excludes traits defined on parent classes. View Source @ classmethod def class_config_rst_doc ( cls ): \"\"\"Generate rST documentation for this class' config options. Excludes traits defined on parent classes. \"\"\" lines = [] classname = cls . __name__ for k , trait in sorted ( cls . class_traits ( config = True ) . items ()): ttype = trait . __class__ . __name__ termline = classname + '.' + trait . name # Choices or type if 'Enum' in ttype : # include Enum choices termline += ' : ' + trait . info_rst () else : termline += ' : ' + ttype lines . append ( termline ) # Default value try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [: 61 ] + '...' # Double up backslashes, so they get to the rendered docs dvr = dvr . replace ( \" \\\\ n\" , \" \\\\\\\\ n\" ) lines . append ( indent ( \"Default: `` %s ``\" % dvr )) lines . append ( \"\" ) help = trait . help or 'No description' lines . append ( indent ( dedent ( help ))) # Blank line lines . append ( '' ) return ' \\n ' . join ( lines ) class_config_section def class_config_section ( classes = None ) Get the config section for this class. Parameters: Name Type Description Default classes list The list of other classes in the config file. Used to reduce redundant information. None View Source @classmethod def class_config_section ( cls , classes = None ) : \"\"\"Get the config section for this class. Parameters ---------- classes : list, optional The list of other classes in the config file. Used to reduce redundant information. \"\"\" def c ( s ) : \"\"\"return a commented, wrapped block.\"\"\" s = '\\n\\n' . join ( wrap_paragraphs ( s , 78 )) return '## ' + s . replace ( '\\n' , '\\n# ' ) # section header breaker = '#' + '-' * 78 parent_classes = ', ' . join ( p . __name__ for p in cls . __bases__ if issubclass ( p , Configurable ) ) s = \"# %s(%s) configuration\" % ( cls . __name__ , parent_classes ) lines = [ breaker, s, breaker ] # get the description trait desc = cls . class_traits (). get ( 'description' ) if desc : desc = desc . default_value if not desc : # no description from trait , use __doc__ desc = getattr ( cls , '__doc__' , '' ) if desc : lines . append ( c ( desc )) lines . append ( '' ) for name , trait in sorted ( cls . class_traits ( config = True ). items ()) : default_repr = trait . default_value_repr () if classes : defining_class = cls . _defining_class ( trait , classes ) else : defining_class = cls if defining_class is cls : # cls owns the trait , show full help if trait . help : lines . append ( c ( trait . help )) if 'Enum' in type ( trait ). __name__ : # include Enum choices lines . append ( '# Choices: %s' % trait . info ()) lines . append ( '# Default: %s' % default_repr ) else : # Trait appears multiple times and isn 't defined here. # Truncate help to first line + \"See also Original.trait\" if trait.help: lines.append(c(trait.help.split(' \\ n ', 1)[0])) lines.append(' # See also : % s . % s ' % (defining_class.__name__, name)) lines.append(' # c . % s . % s = % s ' % (cls.__name__, name, default_repr)) lines.append('') return ' \\ n ' . join ( lines ) class_get_help def class_get_help ( inst = None ) Get the help string for this class in ReST format. If inst is given, it's current trait values will be used in place of class defaults. View Source @classmethod def class_get_help ( cls , inst = None ) : \" \"\" Get the help string for this class in ReST format. If `inst` is given, it's current trait values will be used in place of class defaults. \"\" \" assert inst is None or isinstance ( inst , cls ) final_help = [] base_classes = ', ' . join ( p . __name__ for p in cls . __bases__ ) final_help . append ( '%s(%s) options' % ( cls . __name__ , base_classes )) final_help . append ( len ( final_help [ 0 ] ) * '-' ) for k , v in sorted ( cls . class_traits ( config = True ). items ()) : help = cls . class_get_trait_help ( v , inst ) final_help . append ( help ) return ' \\n ' . join ( final_help ) class_get_trait_help def class_get_trait_help ( trait , inst = None , helptext = None ) Get the helptext string for a single trait. Parameters: Name Type Description Default inst None If given, it's current trait values will be used in place of the class default. None helptext None If not given, uses the help attribute of the current trait. None View Source @classmethod def class_get_trait_help ( cls , trait , inst = None , helptext = None ) : \" \"\" Get the helptext string for a single trait. :param inst: If given, it's current trait values will be used in place of the class default. :param helptext: If not given, uses the `help` attribute of the current trait. \"\" \" assert inst is None or isinstance ( inst , cls ) lines = [] header = \"--%s.%s\" % ( cls . __name__ , trait . name ) if isinstance ( trait , ( Container , Dict )) : multiplicity = trait . metadata . get ( 'multiplicity' , 'append' ) if isinstance ( trait , Dict ) : sample_value = '<key-1>=<value-1>' else : sample_value = '<%s-item-1>' % trait . __class__ . __name__ . lower () if multiplicity == 'append' : header = \"%s=%s...\" % ( header , sample_value ) else : header = \"%s %s...\" % ( header , sample_value ) else : header = '%s=<%s>' % ( header , trait . __class__ . __name__ ) #header = \"--%s.%s=<%s>\" % (cls.__name__, trait.name, trait.__class__.__name__) lines . append ( header ) if helptext is None : helptext = trait . help if helptext != '' : helptext = ' \\n ' . join ( wrap_paragraphs ( helptext , 76 )) lines . append ( indent ( helptext )) if 'Enum' in trait . __class__ . __name__ : # include Enum choices lines . append ( indent ( 'Choices: %s' % trait . info ())) if inst is not None : lines . append ( indent ( \"Current: %r\" % ( getattr ( inst , trait . name ),))) else : try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [ : 61 ] + \"...\" lines . append ( indent ( \"Default: %s\" % dvr )) return ' \\n ' . join ( lines ) class_own_trait_events def class_own_trait_events ( name ) Get a dict of all event handlers defined on this class, not a parent. Works like event_handlers , except for excluding traits from parents. View Source @classmethod def class_own_trait_events ( cls , name ) : \" \"\" Get a dict of all event handlers defined on this class, not a parent. Works like ``event_handlers``, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : e for ( n , e ) in cls . events ( name ). items () if getattr ( sup , n , None ) is not e } class_own_traits def class_own_traits ( ** metadata ) Get a dict of all the traitlets defined on this class, not a parent. Works like class_traits , except for excluding traits from parents. View Source @classmethod def class_own_traits ( cls , ** metadata ) : \" \"\" Get a dict of all the traitlets defined on this class, not a parent. Works like `class_traits`, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : t for ( n , t ) in cls . class_traits ( ** metadata ). items () if getattr ( sup , n , None ) is not t } class_print_help def class_print_help ( inst = None ) Get the help string for a single trait and print it. View Source @classmethod def class_print_help ( cls , inst = None ) : \"\"\"Get the help string for a single trait and print it.\"\"\" print ( cls . class_get_help ( inst )) class_trait_names def class_trait_names ( ** metadata ) Get a list of all the names of this class' traits. This method is just like the :meth: trait_names method, but is unbound. View Source @classmethod def class_trait_names ( cls , ** metadata ) : \" \"\" Get a list of all the names of this class' traits. This method is just like the :meth:`trait_names` method, but is unbound. \"\" \" return list ( cls . class_traits ( ** metadata )) class_traits def class_traits ( ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth: traits method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source @classmethod def class_traits ( cls , ** metadata ) : \" \"\" Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth:`traits` method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\" \" traits = dict ( [ memb for memb in getmembers ( cls ) if isinstance ( memb [ 1 ] , TraitType ) ] ) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items () : for meta_name , meta_eval in metadata . items () : if not callable ( meta_eval ) : meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )) : break else : result [ name ] = trait return result section_names def section_names ( ) return section names as a list View Source @classmethod def section_names ( cls ) : \"\"\"return section names as a list\"\"\" return [ c.__name__ for c in reversed(cls.__mro__) if issubclass(c, Configurable) and issubclass(cls, c) ] trait_events def trait_events ( name = None ) Get a dict of all the event handlers of this class. Parameters: Name Type Description Default name str (default: None) The name of a trait of this class. If name is None then all the event handlers of this class will be returned instead. None Returns: Type Description The event handlers associated with a trait name, or all event handlers. None View Source @classmethod def trait_events ( cls , name = None ) : \"\"\"Get a ``dict`` of all the event handlers of this class. Parameters ---------- name : str (default: None) The name of a trait of this class. If name is ``None`` then all the event handlers of this class will be returned instead. Returns ------- The event handlers associated with a trait name, or all event handlers. \"\"\" events = {} for k , v in getmembers ( cls ) : if isinstance ( v , EventHandler ) : if name is None : events [ k ] = v elif name in v . trait_names : events [ k ] = v elif hasattr ( v , 'tags' ) : if cls . trait_names ( ** v . tags ) : events [ k ] = v return events Instance variables cross_validation_lock A contextmanager for running a block with our cross validation lock set to True. At the end of the block, the lock's value is restored to its value prior to entering the block. Methods add_traits def add_traits ( self , ** traits ) Dynamically add trait attributes to the HasTraits instance. View Source def add_traits ( self , ** traits ) : \"\"\" Dynamically add trait attributes to the HasTraits instance. \"\"\" cls = self . __class__ attrs = { \" __module__ \" : cls . __module__ } if hasattr ( cls , \" __qualname__ \" ) : # __qualname__ introduced in Python 3 . 3 ( see PEP 3155 ) attrs [ \" __qualname__ \" ] = cls . __qualname__ attrs . update ( traits ) self . __class__ = type ( cls . __name__ , ( cls , ) , attrs ) for trait in traits . values () : trait . instance_init ( self ) arg_err def arg_err ( self , func ) Print docstring if incorrect arguments were passed View Source def arg_err ( self , func ) : \"\"\" Print docstring if incorrect arguments were passed \"\"\" print ( ' Error in arguments: ' ) print ( oinspect . getdoc ( func )) default_option def default_option ( self , fn , optstr ) Make an entry in the options_table for fn, with value optstr View Source def default_option ( self , fn , optstr ) : \"\"\"Make an entry in the options_table for fn, with value optstr\"\"\" if fn not in self . lsmagic () : error ( \"%s is not a magic function\" % fn ) self . options_table [ fn ] = optstr dotenv def dotenv ( self , line ) View Source @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) format_latex def format_latex ( self , strng ) Format a string for latex inclusion. View Source def format_latex ( self , strng ) : \"\"\" Format a string for latex inclusion. \"\"\" # Characters that need to be escaped for latex : escape_re = re . compile ( r ' (%|_|\\$|#|&) ' , re . MULTILINE ) # Magic command names as headers : cmd_name_re = re . compile ( r ' ^(%s.*?): ' % ESC_MAGIC , re . MULTILINE ) # Magic commands cmd_re = re . compile ( r ' (?P<cmd>%s.+?\\b)(?!\\}\\}:) ' % ESC_MAGIC , re . MULTILINE ) # Paragraph continue par_re = re . compile ( r ' \\\\ $ ' , re . MULTILINE ) # The \" \\n \" symbol newline_re = re . compile ( r ' \\\\ n ' ) # Now build the string for output : # strng = cmd_name_re . sub ( r ' \\n\\\\ texttt{ \\\\ textsl{ \\\\ large \\1}}: ' , strng ) strng = cmd_name_re . sub ( r ' \\n\\\\ bigskip \\n\\\\ texttt{ \\\\ textbf{ \\1}}: ' , strng ) strng = cmd_re . sub ( r ' \\\\ texttt{\\g<cmd>} ' , strng ) strng = par_re . sub ( r ' \\\\\\\\ ' , strng ) strng = escape_re . sub ( r ' \\\\ \\1 ' , strng ) strng = newline_re . sub ( r ' \\\\ textbackslash{}n ' , strng ) return strng has_trait def has_trait ( self , name ) Returns True if the object has a trait with the specified name. View Source def has_trait ( self , name ) : \"\"\" Returns True if the object has a trait with the specified name. \"\"\" return isinstance ( getattr ( self . __class__ , name , None ) , TraitType ) hold_trait_notifications def hold_trait_notifications ( self ) Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. View Source @contextlib . contextmanager def hold_trait_notifications ( self ) : \"\"\"Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. \"\"\" if self . _ cross_validation_lock: yield return else : cache = {} notify_change = self . notify_change def compress ( past_changes , change ) : \"\"\"Merges the provided change with the last if possible.\"\"\" if past_changes is None : return [ change ] else : if past_changes [ - 1 ][ 'type' ] == 'change' and change . type == 'change': past_changes [ - 1 ][ 'new' ] = change . new else : # In case of changes other than 'change' , append the notification . past_changes . append ( change ) return past_changes def hold ( change ) : name = change . name cache [ name ] = compress ( cache . get ( name ), change ) try : # Replace notify_change with ` hold ` , caching and compressing # notifications , disable cross validation and yield . self . notify_change = hold self . _ cross_validation_lock = True yield # Cross validate final values when context is released . for name in list ( cache . keys ()) : trait = getattr ( self . __ class__ , name ) value = trait . _ cross_validate ( self , getattr ( self , name )) self . set_trait ( name , value ) except TraitError as e : # Roll back in case of TraitError during final cross validation . self . notify_change = lambda x : None for name , changes in cache . items () : for change in changes [ ::- 1 ] : # TODO : Separate in a rollback function per notification type . if change . type == 'change': if change . old is not Undefined : self . set_trait ( name , change . old ) else : self . _ trait_values . pop ( name ) cache = {} raise e finally : self . _ cross_validation_lock = False # Restore method retrieval from class del self . notify_change # trigger delayed notifications for changes in cache . values () : for change in changes : self . notify_change ( change ) notify_change def notify_change ( self , change ) Notify observers of a change event View Source def notify_change ( self , change ) : \"\"\" Notify observers of a change event \"\"\" return self . _notify_observers ( change ) observe def observe ( self , handler , names = traitlets . All , type = 'change' ) Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters: Name Type Description Default handler callable A callable that is called when a trait changes. Its signature should be handler(change) , where change is a dictionary. The change dictionary at least holds a 'type' key. * type : the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * owner : the HasTraits instance * old : the old value of the modified trait attribute * new : the new value of the modified trait attribute * name : the name of the modified trait attribute. None names list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. None type str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. None View Source def observe ( self , handler , names = All , type = 'change' ) : \" \"\" Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters ---------- handler : callable A callable that is called when a trait changes. Its signature should be ``handler(change)``, where ``change`` is a dictionary. The change dictionary at least holds a 'type' key. * ``type``: the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * ``owner`` : the HasTraits instance * ``old`` : the old value of the modified trait attribute * ``new`` : the new value of the modified trait attribute * ``name`` : the name of the modified trait attribute. names : list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. type : str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. \"\" \" names = parse_notifier_name ( names ) for n in names : self . _add_notifiers ( handler , n , type ) on_trait_change def on_trait_change ( self , handler = None , name = None , remove = False ) DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If remove is True and handler is not specified, all change handlers for the specified name are uninstalled. Parameters: Name Type Description Default handler callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). None name list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. None remove bool If False (the default), then install the handler. If True then unintall it. None View Source def on_trait_change ( self , handler = None , name = None , remove = False ) : \" \"\" DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If `remove` is True and `handler` is not specified, all change handlers for the specified name are uninstalled. Parameters ---------- handler : callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). name : list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. remove : bool If False (the default), then install the handler. If True then unintall it. \"\" \" warn ( \"on_trait_change is deprecated in traitlets 4.1: use observe instead\" , DeprecationWarning , stacklevel = 2 ) if name is None : name = All if remove : self . unobserve ( _callback_wrapper ( handler ), names = name ) else : self . observe ( _callback_wrapper ( handler ), names = name ) parse_options def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) Parse options passed to an argument string. The interface is similar to that of :func: getopt.getopt , but it returns a :class: ~IPython.utils.struct.Struct with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters: Name Type Description Default arg_str str The arguments to parse. None opt_str str The options specification. None mode str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. None list_all bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. None posix bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod: shlex module from the standard library. None View Source def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) : \"\"\"Parse options passed to an argument string. The interface is similar to that of :func:`getopt.getopt`, but it returns a :class:`~IPython.utils.struct.Struct` with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters ---------- arg_str : str The arguments to parse. opt_str : str The options specification. mode : str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. list_all : bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. posix : bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod:`shlex` module from the standard library. \"\"\" # inject default options at the beginning of the input line caller = sys . _getframe ( 1 ). f_code . co_name arg_str = '%s %s' % ( self . options_table . get ( caller , '' ), arg_str ) mode = kw . get ( 'mode' , 'string' ) if mode not in [ 'string','list' ] : raise ValueError ( 'incorrect mode given: %s' % mode ) # Get options list_all = kw . get ( 'list_all' , 0 ) posix = kw . get ( 'posix' , os . name == 'posix' ) strict = kw . get ( 'strict' , True ) preserve_non_opts = kw . get ( \"preserve_non_opts\" , False ) remainder_arg_str = arg_str # Check if we have more than one argument to warrant extra processing : odict = {} # Dictionary with options args = arg_str . split () if len ( args ) >= 1 : # If the list of inputs only has 0 or 1 thing in it , there 's no # need to look for options argv = arg_split(arg_str, posix, strict) # Do regular option processing try: opts,args = getopt(argv, opt_str, long_opts) except GetoptError as e: raise UsageError( ' % s ( allowed : \"%s\" % s ) ' % (e.msg, opt_str, \" \".join(long_opts)) ) from e for o, a in opts: if mode == \"string\" and preserve_non_opts: # remove option-parts from the original args-string and preserve remaining-part. # This relies on the arg_split(...) and getopt(...)' s impl spec , that the parsed options are # returned in the original order . remainder_arg_str = remainder_arg_str . replace ( o , \"\" , 1 ). replace ( a , \"\" , 1 ) if o . startswith ( \"--\" ) : o = o [ 2: ] else : o = o [ 1: ] try : odict [ o ] . append ( a ) except AttributeError : odict [ o ] = [ odict[o ] , a ] except KeyError : if list_all : odict [ o ] = [ a ] else : odict [ o ] = a # Prepare opts , args for return opts = Struct ( odict ) if mode == 'string' : if preserve_non_opts : args = remainder_arg_str . lstrip () else : args = \" \" . join ( args ) return opts , args set_trait def set_trait ( self , name , value ) Forcibly sets trait attribute, including read-only attributes. View Source def set_trait ( self , name , value ) : \"\"\" Forcibly sets trait attribute, including read-only attributes. \"\"\" cls = self . __class__ if not self . has_trait ( name ) : raise TraitError ( \" Class %s does not have a trait named %s \" % ( cls . __name__ , name )) else : getattr ( cls , name ) . set ( self , value ) setup_instance def setup_instance ( * args , ** kwargs ) This is called before self. init is called. View Source def setup_instance(*args, **kwargs): # Pass self as args[0] to allow \"self\" as keyword argument self = args[0] args = args[1:] self._trait_values = {} self._trait_notifiers = {} self._trait_validators = {} super(HasTraits, self).setup_instance(*args, **kwargs) trait_defaults def trait_defaults ( self , * names , ** metadata ) Return a trait's default value or a dictionary of them View Source def trait_defaults ( self , * names , ** metadata ) : \"\"\"Return a trait's default value or a dictionary of them Notes ----- Dynamically generated default values may depend on the current state of the object.\"\"\" for n in names : if not self . has_trait ( n ) : raise TraitError ( \"'%s' is not a trait of '%s' \" \"instances\" % ( n , type ( self ). __name__ )) if len ( names ) == 1 and len ( metadata ) == 0 : return self . _get_trait_default_generator ( names [ 0 ] )( self ) trait_names = self . trait_names ( ** metadata ) trait_names . extend ( names ) defaults = {} for n in trait_names : defaults [ n ] = self . _get_trait_default_generator ( n )( self ) return defaults trait_has_value def trait_has_value ( self , name ) Returns True if the specified trait has a value. This will return false even if getattr would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass ( HasTraits ): i = Int () mc = MyClass () assert not mc . trait_has_value ( \"i\" ) mc . i # generates a default value assert mc . trait_has_value ( \"i\" ) View Source def trait_has_value ( self , name ) : \" \"\" Returns True if the specified trait has a value. This will return false even if ``getattr`` would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass(HasTraits): i = Int() mc = MyClass() assert not mc.trait_has_value(\" i \") mc.i # generates a default value assert mc.trait_has_value(\" i \") \"\" \" return name in self . _trait_values trait_metadata def trait_metadata ( self , traitname , key , default = None ) Get metadata values for trait by key. View Source def trait_metadata ( self , traitname , key , default = None ) : \"\"\" Get metadata values for trait by key. \"\"\" try : trait = getattr ( self . __class__ , traitname ) except AttributeError : raise TraitError ( \" Class %s does not have a trait named %s \" % ( self . __class__ . __name__ , traitname )) metadata_name = ' _ ' + traitname + ' _metadata ' if hasattr ( self , metadata_name ) and key in getattr ( self , metadata_name ) : return getattr ( self , metadata_name ) . get ( key , default ) else : return trait . metadata . get ( key , default ) trait_names def trait_names ( self , ** metadata ) Get a list of all the names of this class' traits. View Source def trait_names ( self , ** metadata ) : \"\"\" Get a list of all the names of this class' traits. \"\"\" return list ( self . traits ( ** metadata )) trait_values def trait_values ( self , ** metadata ) A dict of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns: Type Description A dict of trait names and their values. None View Source def trait_values ( self , ** metadata ) : \" \"\" A ``dict`` of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns ------- A ``dict`` of trait names and their values. Notes ----- Trait values are retrieved via ``getattr``, any exceptions raised by traits or the operations they may trigger will result in the absence of a trait value in the result ``dict``. \"\" \" return { name : getattr ( self , name ) for name in self . trait_names ( ** metadata ) } traits def traits ( self , ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source def traits ( self , ** metadata ): \"\"\"Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\"\" traits = dict ([ memb for memb in getmembers ( self . __class__ ) if isinstance ( memb [ 1 ], TraitType )]) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items (): for meta_name , meta_eval in metadata . items (): if not callable ( meta_eval ): meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )): break else : result [ name ] = trait return result unobserve def unobserve ( self , handler , names = traitlets . All , type = 'change' ) Remove a trait change handler. This is used to unregister handlers to trait change notifications. Parameters: Name Type Description Default handler callable The callable called when a trait attribute changes. None names list, str, All (default: All) The names of the traits for which the specified handler should be uninstalled. If names is All, the specified handler is uninstalled from the list of notifiers corresponding to all changes. None type str or All (default: 'change') The type of notification to filter by. If All, the specified handler is uninstalled from the list of notifiers corresponding to all types. None View Source def unobserve ( self , handler , names = All , type = ' change ') : \"\"\"Remove a trait change handler. This is used to unregister handlers to trait change notifications . Parameters ---------- handler : callable The callable called when a trait attribute changes . names : list , str , All ( default : All ) The names of the traits for which the specified handler should be uninstalled . If names is All , the specified handler is uninstalled from the list of notifiers corresponding to all changes . type : str or All ( default : ' change ') The type of notification to filter by . If All , the specified handler is uninstalled from the list of notifiers corresponding to all types . \"\"\" names = parse_notifier_name ( names ) for n in names: self . _remove_notifiers ( handler , n , type ) unobserve_all def unobserve_all ( self , name = traitlets . All ) Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers. View Source def unobserve_all ( self , name = All ) : \"\"\"Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers.\"\"\" if name is All : self . _trait_notifiers = {} else : try : del self . _trait_notifiers [ name ] except KeyError : pass update_config def update_config ( self , config ) Update config and load the new values View Source def update_config ( self , config ): \"\"\"Update config and load the new values\"\"\" # traitlets prior to 4.2 created a copy of self.config in order to trigger change events. # Some projects (IPython < 5) relied upon one side effect of this, # that self.config prior to update_config was not modified in-place. # For backward-compatibility, we must ensure that self.config # is a new object and not modified in-place, # but config consumers should not rely on this behavior. self . config = deepcopy ( self . config ) # load config self . _load_config ( config ) # merge it into self.config self . config . merge ( config ) # TODO: trigger change event if/when dict-update change events take place # DO NOT trigger full trait-change","title":"Ipython"},{"location":"reference/dotenv/ipython/#module-dotenvipython","text":"None None View Source from IPython.core.magic import Magics , line_magic , magics_class # type: ignore from IPython.core.magic_arguments import ( argument , magic_arguments , # type: ignore parse_argstring ) # type: ignore from .main import find_dotenv , load_dotenv @magics_class class IPythonDotEnv ( Magics ): @magic_arguments () @argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv )","title":"Module dotenv.ipython"},{"location":"reference/dotenv/ipython/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/ipython/#load_ipython_extension","text":"def load_ipython_extension ( ipython ) Register the %dotenv magic. View Source def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv )","title":"load_ipython_extension"},{"location":"reference/dotenv/ipython/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/ipython/#ipythondotenv","text":"class IPythonDotEnv ( shell = None , ** kwargs ) View Source @ magics_class class IPythonDotEnv ( Magics ): @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override )","title":"IPythonDotEnv"},{"location":"reference/dotenv/ipython/#ancestors-in-mro","text":"IPython.core.magic.Magics traitlets.config.configurable.Configurable traitlets.traitlets.HasTraits traitlets.traitlets.HasDescriptors","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/ipython/#class-variables","text":"config magics options_table parent registered shell","title":"Class variables"},{"location":"reference/dotenv/ipython/#static-methods","text":"","title":"Static methods"},{"location":"reference/dotenv/ipython/#class_config_rst_doc","text":"def class_config_rst_doc ( ) Generate rST documentation for this class' config options. Excludes traits defined on parent classes. View Source @ classmethod def class_config_rst_doc ( cls ): \"\"\"Generate rST documentation for this class' config options. Excludes traits defined on parent classes. \"\"\" lines = [] classname = cls . __name__ for k , trait in sorted ( cls . class_traits ( config = True ) . items ()): ttype = trait . __class__ . __name__ termline = classname + '.' + trait . name # Choices or type if 'Enum' in ttype : # include Enum choices termline += ' : ' + trait . info_rst () else : termline += ' : ' + ttype lines . append ( termline ) # Default value try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [: 61 ] + '...' # Double up backslashes, so they get to the rendered docs dvr = dvr . replace ( \" \\\\ n\" , \" \\\\\\\\ n\" ) lines . append ( indent ( \"Default: `` %s ``\" % dvr )) lines . append ( \"\" ) help = trait . help or 'No description' lines . append ( indent ( dedent ( help ))) # Blank line lines . append ( '' ) return ' \\n ' . join ( lines )","title":"class_config_rst_doc"},{"location":"reference/dotenv/ipython/#class_config_section","text":"def class_config_section ( classes = None ) Get the config section for this class. Parameters: Name Type Description Default classes list The list of other classes in the config file. Used to reduce redundant information. None View Source @classmethod def class_config_section ( cls , classes = None ) : \"\"\"Get the config section for this class. Parameters ---------- classes : list, optional The list of other classes in the config file. Used to reduce redundant information. \"\"\" def c ( s ) : \"\"\"return a commented, wrapped block.\"\"\" s = '\\n\\n' . join ( wrap_paragraphs ( s , 78 )) return '## ' + s . replace ( '\\n' , '\\n# ' ) # section header breaker = '#' + '-' * 78 parent_classes = ', ' . join ( p . __name__ for p in cls . __bases__ if issubclass ( p , Configurable ) ) s = \"# %s(%s) configuration\" % ( cls . __name__ , parent_classes ) lines = [ breaker, s, breaker ] # get the description trait desc = cls . class_traits (). get ( 'description' ) if desc : desc = desc . default_value if not desc : # no description from trait , use __doc__ desc = getattr ( cls , '__doc__' , '' ) if desc : lines . append ( c ( desc )) lines . append ( '' ) for name , trait in sorted ( cls . class_traits ( config = True ). items ()) : default_repr = trait . default_value_repr () if classes : defining_class = cls . _defining_class ( trait , classes ) else : defining_class = cls if defining_class is cls : # cls owns the trait , show full help if trait . help : lines . append ( c ( trait . help )) if 'Enum' in type ( trait ). __name__ : # include Enum choices lines . append ( '# Choices: %s' % trait . info ()) lines . append ( '# Default: %s' % default_repr ) else : # Trait appears multiple times and isn 't defined here. # Truncate help to first line + \"See also Original.trait\" if trait.help: lines.append(c(trait.help.split(' \\ n ', 1)[0])) lines.append(' # See also : % s . % s ' % (defining_class.__name__, name)) lines.append(' # c . % s . % s = % s ' % (cls.__name__, name, default_repr)) lines.append('') return ' \\ n ' . join ( lines )","title":"class_config_section"},{"location":"reference/dotenv/ipython/#class_get_help","text":"def class_get_help ( inst = None ) Get the help string for this class in ReST format. If inst is given, it's current trait values will be used in place of class defaults. View Source @classmethod def class_get_help ( cls , inst = None ) : \" \"\" Get the help string for this class in ReST format. If `inst` is given, it's current trait values will be used in place of class defaults. \"\" \" assert inst is None or isinstance ( inst , cls ) final_help = [] base_classes = ', ' . join ( p . __name__ for p in cls . __bases__ ) final_help . append ( '%s(%s) options' % ( cls . __name__ , base_classes )) final_help . append ( len ( final_help [ 0 ] ) * '-' ) for k , v in sorted ( cls . class_traits ( config = True ). items ()) : help = cls . class_get_trait_help ( v , inst ) final_help . append ( help ) return ' \\n ' . join ( final_help )","title":"class_get_help"},{"location":"reference/dotenv/ipython/#class_get_trait_help","text":"def class_get_trait_help ( trait , inst = None , helptext = None ) Get the helptext string for a single trait. Parameters: Name Type Description Default inst None If given, it's current trait values will be used in place of the class default. None helptext None If not given, uses the help attribute of the current trait. None View Source @classmethod def class_get_trait_help ( cls , trait , inst = None , helptext = None ) : \" \"\" Get the helptext string for a single trait. :param inst: If given, it's current trait values will be used in place of the class default. :param helptext: If not given, uses the `help` attribute of the current trait. \"\" \" assert inst is None or isinstance ( inst , cls ) lines = [] header = \"--%s.%s\" % ( cls . __name__ , trait . name ) if isinstance ( trait , ( Container , Dict )) : multiplicity = trait . metadata . get ( 'multiplicity' , 'append' ) if isinstance ( trait , Dict ) : sample_value = '<key-1>=<value-1>' else : sample_value = '<%s-item-1>' % trait . __class__ . __name__ . lower () if multiplicity == 'append' : header = \"%s=%s...\" % ( header , sample_value ) else : header = \"%s %s...\" % ( header , sample_value ) else : header = '%s=<%s>' % ( header , trait . __class__ . __name__ ) #header = \"--%s.%s=<%s>\" % (cls.__name__, trait.name, trait.__class__.__name__) lines . append ( header ) if helptext is None : helptext = trait . help if helptext != '' : helptext = ' \\n ' . join ( wrap_paragraphs ( helptext , 76 )) lines . append ( indent ( helptext )) if 'Enum' in trait . __class__ . __name__ : # include Enum choices lines . append ( indent ( 'Choices: %s' % trait . info ())) if inst is not None : lines . append ( indent ( \"Current: %r\" % ( getattr ( inst , trait . name ),))) else : try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [ : 61 ] + \"...\" lines . append ( indent ( \"Default: %s\" % dvr )) return ' \\n ' . join ( lines )","title":"class_get_trait_help"},{"location":"reference/dotenv/ipython/#class_own_trait_events","text":"def class_own_trait_events ( name ) Get a dict of all event handlers defined on this class, not a parent. Works like event_handlers , except for excluding traits from parents. View Source @classmethod def class_own_trait_events ( cls , name ) : \" \"\" Get a dict of all event handlers defined on this class, not a parent. Works like ``event_handlers``, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : e for ( n , e ) in cls . events ( name ). items () if getattr ( sup , n , None ) is not e }","title":"class_own_trait_events"},{"location":"reference/dotenv/ipython/#class_own_traits","text":"def class_own_traits ( ** metadata ) Get a dict of all the traitlets defined on this class, not a parent. Works like class_traits , except for excluding traits from parents. View Source @classmethod def class_own_traits ( cls , ** metadata ) : \" \"\" Get a dict of all the traitlets defined on this class, not a parent. Works like `class_traits`, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : t for ( n , t ) in cls . class_traits ( ** metadata ). items () if getattr ( sup , n , None ) is not t }","title":"class_own_traits"},{"location":"reference/dotenv/ipython/#class_print_help","text":"def class_print_help ( inst = None ) Get the help string for a single trait and print it. View Source @classmethod def class_print_help ( cls , inst = None ) : \"\"\"Get the help string for a single trait and print it.\"\"\" print ( cls . class_get_help ( inst ))","title":"class_print_help"},{"location":"reference/dotenv/ipython/#class_trait_names","text":"def class_trait_names ( ** metadata ) Get a list of all the names of this class' traits. This method is just like the :meth: trait_names method, but is unbound. View Source @classmethod def class_trait_names ( cls , ** metadata ) : \" \"\" Get a list of all the names of this class' traits. This method is just like the :meth:`trait_names` method, but is unbound. \"\" \" return list ( cls . class_traits ( ** metadata ))","title":"class_trait_names"},{"location":"reference/dotenv/ipython/#class_traits","text":"def class_traits ( ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth: traits method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source @classmethod def class_traits ( cls , ** metadata ) : \" \"\" Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth:`traits` method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\" \" traits = dict ( [ memb for memb in getmembers ( cls ) if isinstance ( memb [ 1 ] , TraitType ) ] ) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items () : for meta_name , meta_eval in metadata . items () : if not callable ( meta_eval ) : meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )) : break else : result [ name ] = trait return result","title":"class_traits"},{"location":"reference/dotenv/ipython/#section_names","text":"def section_names ( ) return section names as a list View Source @classmethod def section_names ( cls ) : \"\"\"return section names as a list\"\"\" return [ c.__name__ for c in reversed(cls.__mro__) if issubclass(c, Configurable) and issubclass(cls, c) ]","title":"section_names"},{"location":"reference/dotenv/ipython/#trait_events","text":"def trait_events ( name = None ) Get a dict of all the event handlers of this class. Parameters: Name Type Description Default name str (default: None) The name of a trait of this class. If name is None then all the event handlers of this class will be returned instead. None Returns: Type Description The event handlers associated with a trait name, or all event handlers. None View Source @classmethod def trait_events ( cls , name = None ) : \"\"\"Get a ``dict`` of all the event handlers of this class. Parameters ---------- name : str (default: None) The name of a trait of this class. If name is ``None`` then all the event handlers of this class will be returned instead. Returns ------- The event handlers associated with a trait name, or all event handlers. \"\"\" events = {} for k , v in getmembers ( cls ) : if isinstance ( v , EventHandler ) : if name is None : events [ k ] = v elif name in v . trait_names : events [ k ] = v elif hasattr ( v , 'tags' ) : if cls . trait_names ( ** v . tags ) : events [ k ] = v return events","title":"trait_events"},{"location":"reference/dotenv/ipython/#instance-variables","text":"cross_validation_lock A contextmanager for running a block with our cross validation lock set to True. At the end of the block, the lock's value is restored to its value prior to entering the block.","title":"Instance variables"},{"location":"reference/dotenv/ipython/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/ipython/#add_traits","text":"def add_traits ( self , ** traits ) Dynamically add trait attributes to the HasTraits instance. View Source def add_traits ( self , ** traits ) : \"\"\" Dynamically add trait attributes to the HasTraits instance. \"\"\" cls = self . __class__ attrs = { \" __module__ \" : cls . __module__ } if hasattr ( cls , \" __qualname__ \" ) : # __qualname__ introduced in Python 3 . 3 ( see PEP 3155 ) attrs [ \" __qualname__ \" ] = cls . __qualname__ attrs . update ( traits ) self . __class__ = type ( cls . __name__ , ( cls , ) , attrs ) for trait in traits . values () : trait . instance_init ( self )","title":"add_traits"},{"location":"reference/dotenv/ipython/#arg_err","text":"def arg_err ( self , func ) Print docstring if incorrect arguments were passed View Source def arg_err ( self , func ) : \"\"\" Print docstring if incorrect arguments were passed \"\"\" print ( ' Error in arguments: ' ) print ( oinspect . getdoc ( func ))","title":"arg_err"},{"location":"reference/dotenv/ipython/#default_option","text":"def default_option ( self , fn , optstr ) Make an entry in the options_table for fn, with value optstr View Source def default_option ( self , fn , optstr ) : \"\"\"Make an entry in the options_table for fn, with value optstr\"\"\" if fn not in self . lsmagic () : error ( \"%s is not a magic function\" % fn ) self . options_table [ fn ] = optstr","title":"default_option"},{"location":"reference/dotenv/ipython/#dotenv","text":"def dotenv ( self , line ) View Source @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override )","title":"dotenv"},{"location":"reference/dotenv/ipython/#format_latex","text":"def format_latex ( self , strng ) Format a string for latex inclusion. View Source def format_latex ( self , strng ) : \"\"\" Format a string for latex inclusion. \"\"\" # Characters that need to be escaped for latex : escape_re = re . compile ( r ' (%|_|\\$|#|&) ' , re . MULTILINE ) # Magic command names as headers : cmd_name_re = re . compile ( r ' ^(%s.*?): ' % ESC_MAGIC , re . MULTILINE ) # Magic commands cmd_re = re . compile ( r ' (?P<cmd>%s.+?\\b)(?!\\}\\}:) ' % ESC_MAGIC , re . MULTILINE ) # Paragraph continue par_re = re . compile ( r ' \\\\ $ ' , re . MULTILINE ) # The \" \\n \" symbol newline_re = re . compile ( r ' \\\\ n ' ) # Now build the string for output : # strng = cmd_name_re . sub ( r ' \\n\\\\ texttt{ \\\\ textsl{ \\\\ large \\1}}: ' , strng ) strng = cmd_name_re . sub ( r ' \\n\\\\ bigskip \\n\\\\ texttt{ \\\\ textbf{ \\1}}: ' , strng ) strng = cmd_re . sub ( r ' \\\\ texttt{\\g<cmd>} ' , strng ) strng = par_re . sub ( r ' \\\\\\\\ ' , strng ) strng = escape_re . sub ( r ' \\\\ \\1 ' , strng ) strng = newline_re . sub ( r ' \\\\ textbackslash{}n ' , strng ) return strng","title":"format_latex"},{"location":"reference/dotenv/ipython/#has_trait","text":"def has_trait ( self , name ) Returns True if the object has a trait with the specified name. View Source def has_trait ( self , name ) : \"\"\" Returns True if the object has a trait with the specified name. \"\"\" return isinstance ( getattr ( self . __class__ , name , None ) , TraitType )","title":"has_trait"},{"location":"reference/dotenv/ipython/#hold_trait_notifications","text":"def hold_trait_notifications ( self ) Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. View Source @contextlib . contextmanager def hold_trait_notifications ( self ) : \"\"\"Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. \"\"\" if self . _ cross_validation_lock: yield return else : cache = {} notify_change = self . notify_change def compress ( past_changes , change ) : \"\"\"Merges the provided change with the last if possible.\"\"\" if past_changes is None : return [ change ] else : if past_changes [ - 1 ][ 'type' ] == 'change' and change . type == 'change': past_changes [ - 1 ][ 'new' ] = change . new else : # In case of changes other than 'change' , append the notification . past_changes . append ( change ) return past_changes def hold ( change ) : name = change . name cache [ name ] = compress ( cache . get ( name ), change ) try : # Replace notify_change with ` hold ` , caching and compressing # notifications , disable cross validation and yield . self . notify_change = hold self . _ cross_validation_lock = True yield # Cross validate final values when context is released . for name in list ( cache . keys ()) : trait = getattr ( self . __ class__ , name ) value = trait . _ cross_validate ( self , getattr ( self , name )) self . set_trait ( name , value ) except TraitError as e : # Roll back in case of TraitError during final cross validation . self . notify_change = lambda x : None for name , changes in cache . items () : for change in changes [ ::- 1 ] : # TODO : Separate in a rollback function per notification type . if change . type == 'change': if change . old is not Undefined : self . set_trait ( name , change . old ) else : self . _ trait_values . pop ( name ) cache = {} raise e finally : self . _ cross_validation_lock = False # Restore method retrieval from class del self . notify_change # trigger delayed notifications for changes in cache . values () : for change in changes : self . notify_change ( change )","title":"hold_trait_notifications"},{"location":"reference/dotenv/ipython/#notify_change","text":"def notify_change ( self , change ) Notify observers of a change event View Source def notify_change ( self , change ) : \"\"\" Notify observers of a change event \"\"\" return self . _notify_observers ( change )","title":"notify_change"},{"location":"reference/dotenv/ipython/#observe","text":"def observe ( self , handler , names = traitlets . All , type = 'change' ) Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters: Name Type Description Default handler callable A callable that is called when a trait changes. Its signature should be handler(change) , where change is a dictionary. The change dictionary at least holds a 'type' key. * type : the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * owner : the HasTraits instance * old : the old value of the modified trait attribute * new : the new value of the modified trait attribute * name : the name of the modified trait attribute. None names list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. None type str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. None View Source def observe ( self , handler , names = All , type = 'change' ) : \" \"\" Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters ---------- handler : callable A callable that is called when a trait changes. Its signature should be ``handler(change)``, where ``change`` is a dictionary. The change dictionary at least holds a 'type' key. * ``type``: the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * ``owner`` : the HasTraits instance * ``old`` : the old value of the modified trait attribute * ``new`` : the new value of the modified trait attribute * ``name`` : the name of the modified trait attribute. names : list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. type : str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. \"\" \" names = parse_notifier_name ( names ) for n in names : self . _add_notifiers ( handler , n , type )","title":"observe"},{"location":"reference/dotenv/ipython/#on_trait_change","text":"def on_trait_change ( self , handler = None , name = None , remove = False ) DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If remove is True and handler is not specified, all change handlers for the specified name are uninstalled. Parameters: Name Type Description Default handler callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). None name list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. None remove bool If False (the default), then install the handler. If True then unintall it. None View Source def on_trait_change ( self , handler = None , name = None , remove = False ) : \" \"\" DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If `remove` is True and `handler` is not specified, all change handlers for the specified name are uninstalled. Parameters ---------- handler : callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). name : list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. remove : bool If False (the default), then install the handler. If True then unintall it. \"\" \" warn ( \"on_trait_change is deprecated in traitlets 4.1: use observe instead\" , DeprecationWarning , stacklevel = 2 ) if name is None : name = All if remove : self . unobserve ( _callback_wrapper ( handler ), names = name ) else : self . observe ( _callback_wrapper ( handler ), names = name )","title":"on_trait_change"},{"location":"reference/dotenv/ipython/#parse_options","text":"def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) Parse options passed to an argument string. The interface is similar to that of :func: getopt.getopt , but it returns a :class: ~IPython.utils.struct.Struct with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters: Name Type Description Default arg_str str The arguments to parse. None opt_str str The options specification. None mode str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. None list_all bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. None posix bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod: shlex module from the standard library. None View Source def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) : \"\"\"Parse options passed to an argument string. The interface is similar to that of :func:`getopt.getopt`, but it returns a :class:`~IPython.utils.struct.Struct` with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters ---------- arg_str : str The arguments to parse. opt_str : str The options specification. mode : str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. list_all : bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. posix : bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod:`shlex` module from the standard library. \"\"\" # inject default options at the beginning of the input line caller = sys . _getframe ( 1 ). f_code . co_name arg_str = '%s %s' % ( self . options_table . get ( caller , '' ), arg_str ) mode = kw . get ( 'mode' , 'string' ) if mode not in [ 'string','list' ] : raise ValueError ( 'incorrect mode given: %s' % mode ) # Get options list_all = kw . get ( 'list_all' , 0 ) posix = kw . get ( 'posix' , os . name == 'posix' ) strict = kw . get ( 'strict' , True ) preserve_non_opts = kw . get ( \"preserve_non_opts\" , False ) remainder_arg_str = arg_str # Check if we have more than one argument to warrant extra processing : odict = {} # Dictionary with options args = arg_str . split () if len ( args ) >= 1 : # If the list of inputs only has 0 or 1 thing in it , there 's no # need to look for options argv = arg_split(arg_str, posix, strict) # Do regular option processing try: opts,args = getopt(argv, opt_str, long_opts) except GetoptError as e: raise UsageError( ' % s ( allowed : \"%s\" % s ) ' % (e.msg, opt_str, \" \".join(long_opts)) ) from e for o, a in opts: if mode == \"string\" and preserve_non_opts: # remove option-parts from the original args-string and preserve remaining-part. # This relies on the arg_split(...) and getopt(...)' s impl spec , that the parsed options are # returned in the original order . remainder_arg_str = remainder_arg_str . replace ( o , \"\" , 1 ). replace ( a , \"\" , 1 ) if o . startswith ( \"--\" ) : o = o [ 2: ] else : o = o [ 1: ] try : odict [ o ] . append ( a ) except AttributeError : odict [ o ] = [ odict[o ] , a ] except KeyError : if list_all : odict [ o ] = [ a ] else : odict [ o ] = a # Prepare opts , args for return opts = Struct ( odict ) if mode == 'string' : if preserve_non_opts : args = remainder_arg_str . lstrip () else : args = \" \" . join ( args ) return opts , args","title":"parse_options"},{"location":"reference/dotenv/ipython/#set_trait","text":"def set_trait ( self , name , value ) Forcibly sets trait attribute, including read-only attributes. View Source def set_trait ( self , name , value ) : \"\"\" Forcibly sets trait attribute, including read-only attributes. \"\"\" cls = self . __class__ if not self . has_trait ( name ) : raise TraitError ( \" Class %s does not have a trait named %s \" % ( cls . __name__ , name )) else : getattr ( cls , name ) . set ( self , value )","title":"set_trait"},{"location":"reference/dotenv/ipython/#setup_instance","text":"def setup_instance ( * args , ** kwargs ) This is called before self. init is called. View Source def setup_instance(*args, **kwargs): # Pass self as args[0] to allow \"self\" as keyword argument self = args[0] args = args[1:] self._trait_values = {} self._trait_notifiers = {} self._trait_validators = {} super(HasTraits, self).setup_instance(*args, **kwargs)","title":"setup_instance"},{"location":"reference/dotenv/ipython/#trait_defaults","text":"def trait_defaults ( self , * names , ** metadata ) Return a trait's default value or a dictionary of them View Source def trait_defaults ( self , * names , ** metadata ) : \"\"\"Return a trait's default value or a dictionary of them Notes ----- Dynamically generated default values may depend on the current state of the object.\"\"\" for n in names : if not self . has_trait ( n ) : raise TraitError ( \"'%s' is not a trait of '%s' \" \"instances\" % ( n , type ( self ). __name__ )) if len ( names ) == 1 and len ( metadata ) == 0 : return self . _get_trait_default_generator ( names [ 0 ] )( self ) trait_names = self . trait_names ( ** metadata ) trait_names . extend ( names ) defaults = {} for n in trait_names : defaults [ n ] = self . _get_trait_default_generator ( n )( self ) return defaults","title":"trait_defaults"},{"location":"reference/dotenv/ipython/#trait_has_value","text":"def trait_has_value ( self , name ) Returns True if the specified trait has a value. This will return false even if getattr would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass ( HasTraits ): i = Int () mc = MyClass () assert not mc . trait_has_value ( \"i\" ) mc . i # generates a default value assert mc . trait_has_value ( \"i\" ) View Source def trait_has_value ( self , name ) : \" \"\" Returns True if the specified trait has a value. This will return false even if ``getattr`` would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass(HasTraits): i = Int() mc = MyClass() assert not mc.trait_has_value(\" i \") mc.i # generates a default value assert mc.trait_has_value(\" i \") \"\" \" return name in self . _trait_values","title":"trait_has_value"},{"location":"reference/dotenv/ipython/#trait_metadata","text":"def trait_metadata ( self , traitname , key , default = None ) Get metadata values for trait by key. View Source def trait_metadata ( self , traitname , key , default = None ) : \"\"\" Get metadata values for trait by key. \"\"\" try : trait = getattr ( self . __class__ , traitname ) except AttributeError : raise TraitError ( \" Class %s does not have a trait named %s \" % ( self . __class__ . __name__ , traitname )) metadata_name = ' _ ' + traitname + ' _metadata ' if hasattr ( self , metadata_name ) and key in getattr ( self , metadata_name ) : return getattr ( self , metadata_name ) . get ( key , default ) else : return trait . metadata . get ( key , default )","title":"trait_metadata"},{"location":"reference/dotenv/ipython/#trait_names","text":"def trait_names ( self , ** metadata ) Get a list of all the names of this class' traits. View Source def trait_names ( self , ** metadata ) : \"\"\" Get a list of all the names of this class' traits. \"\"\" return list ( self . traits ( ** metadata ))","title":"trait_names"},{"location":"reference/dotenv/ipython/#trait_values","text":"def trait_values ( self , ** metadata ) A dict of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns: Type Description A dict of trait names and their values. None View Source def trait_values ( self , ** metadata ) : \" \"\" A ``dict`` of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns ------- A ``dict`` of trait names and their values. Notes ----- Trait values are retrieved via ``getattr``, any exceptions raised by traits or the operations they may trigger will result in the absence of a trait value in the result ``dict``. \"\" \" return { name : getattr ( self , name ) for name in self . trait_names ( ** metadata ) }","title":"trait_values"},{"location":"reference/dotenv/ipython/#traits","text":"def traits ( self , ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source def traits ( self , ** metadata ): \"\"\"Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\"\" traits = dict ([ memb for memb in getmembers ( self . __class__ ) if isinstance ( memb [ 1 ], TraitType )]) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items (): for meta_name , meta_eval in metadata . items (): if not callable ( meta_eval ): meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )): break else : result [ name ] = trait return result","title":"traits"},{"location":"reference/dotenv/ipython/#unobserve","text":"def unobserve ( self , handler , names = traitlets . All , type = 'change' ) Remove a trait change handler. This is used to unregister handlers to trait change notifications. Parameters: Name Type Description Default handler callable The callable called when a trait attribute changes. None names list, str, All (default: All) The names of the traits for which the specified handler should be uninstalled. If names is All, the specified handler is uninstalled from the list of notifiers corresponding to all changes. None type str or All (default: 'change') The type of notification to filter by. If All, the specified handler is uninstalled from the list of notifiers corresponding to all types. None View Source def unobserve ( self , handler , names = All , type = ' change ') : \"\"\"Remove a trait change handler. This is used to unregister handlers to trait change notifications . Parameters ---------- handler : callable The callable called when a trait attribute changes . names : list , str , All ( default : All ) The names of the traits for which the specified handler should be uninstalled . If names is All , the specified handler is uninstalled from the list of notifiers corresponding to all changes . type : str or All ( default : ' change ') The type of notification to filter by . If All , the specified handler is uninstalled from the list of notifiers corresponding to all types . \"\"\" names = parse_notifier_name ( names ) for n in names: self . _remove_notifiers ( handler , n , type )","title":"unobserve"},{"location":"reference/dotenv/ipython/#unobserve_all","text":"def unobserve_all ( self , name = traitlets . All ) Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers. View Source def unobserve_all ( self , name = All ) : \"\"\"Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers.\"\"\" if name is All : self . _trait_notifiers = {} else : try : del self . _trait_notifiers [ name ] except KeyError : pass","title":"unobserve_all"},{"location":"reference/dotenv/ipython/#update_config","text":"def update_config ( self , config ) Update config and load the new values View Source def update_config ( self , config ): \"\"\"Update config and load the new values\"\"\" # traitlets prior to 4.2 created a copy of self.config in order to trigger change events. # Some projects (IPython < 5) relied upon one side effect of this, # that self.config prior to update_config was not modified in-place. # For backward-compatibility, we must ensure that self.config # is a new object and not modified in-place, # but config consumers should not rely on this behavior. self . config = deepcopy ( self . config ) # load config self . _load_config ( config ) # merge it into self.config self . config . merge ( config ) # TODO: trigger change event if/when dict-update change events take place # DO NOT trigger full trait-change","title":"update_config"},{"location":"reference/dotenv/main/","text":"Module dotenv.main None None View Source import io import logging import os import shutil import sys import tempfile from collections import OrderedDict from contextlib import contextmanager from typing import ( IO , Dict , Iterable , Iterator , Mapping , Optional , Tuple , Union ) from .parser import Binding , parse_stream from .variables import parse_variables logger = logging . getLogger ( __name__ ) if sys . version_info >= ( 3 , 6 ): _PathLike = os . PathLike else : _PathLike = str def with_warn_for_invalid_lines ( mappings : Iterator [ Binding ]) -> Iterator [ Binding ]: for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s \" , mapping . original . line , ) yield mapping class DotEnv (): def __init__ ( self , dotenv_path : Optional [ Union [ str , _PathLike ]], stream : Optional [ IO [ str ]] = None , verbose : bool = False , encoding : Union [ None , str ] = None , interpolate : bool = True , override : bool = True , ) -> None : self . dotenv_path = dotenv_path # type: Optional[Union[str, _PathLike]] self . stream = stream # type: Optional[IO[str]] self . _dict = None # type: Optional[Dict[str, Optional[str]]] self . verbose = verbose # type: bool self . encoding = encoding # type: Union[None, str] self . interpolate = interpolate # type: bool self . override = override # type: bool @contextmanager def _get_stream ( self ) -> Iterator [ IO [ str ]]: if self . dotenv_path and os . path . isfile ( self . dotenv_path ): with open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream elif self . stream is not None : yield self . stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s .\" , self . dotenv_path or '.env' , ) yield io . StringIO ( '' ) def dict ( self ) -> Dict [ str , Optional [ str ]]: \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ) -> Iterator [ Tuple [ str , Optional [ str ]]]: with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )): if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ) -> bool : \"\"\" Load the current dotenv as system environment variable. \"\"\" for k , v in self . dict () . items (): if k in os . environ and not self . override : continue if v is not None : os . environ [ k ] = v return True def get ( self , key : str ) -> Optional [ str ]: \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s .\" , key , self . dotenv_path ) return None def get_key ( dotenv_path : Union [ str , _PathLike ], key_to_get : str , encoding : Optional [ str ] = \"utf-8\" , ) -> Optional [ str ]: \"\"\" Get the value of a given key from the given .env. Returns `None` if the key isn't found or doesn't have a value. \"\"\" return DotEnv ( dotenv_path , verbose = True , encoding = encoding ) . get ( key_to_get ) @contextmanager def rewrite ( path : Union [ str , _PathLike ], encoding : Optional [ str ], ) -> Iterator [ Tuple [ IO [ str ], IO [ str ]]]: try : if not os . path . isfile ( path ): with open ( path , \"w+\" , encoding = encoding ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False , encoding = encoding ) as dest : with open ( path , encoding = encoding ) as source : yield ( source , dest ) # type: ignore except BaseException : if os . path . isfile ( dest . name ): os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path ) def set_key ( dotenv_path : Union [ str , _PathLike ], key_to_set : str , value_to_set : str , quote_mode : str = \"always\" , export : bool = False , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional [ bool ], str , str ]: \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" if quote_mode not in ( \"always\" , \"auto\" , \"never\" ): raise ValueError ( \"Unknown quote_mode: {} \" . format ( quote_mode )) quote = ( quote_mode == \"always\" or ( quote_mode == \"auto\" and not value_to_set . isalnum ()) ) if quote : value_out = \"' {} '\" . format ( value_to_set . replace ( \"'\" , \" \\\\ '\" )) else : value_out = value_to_set if export : line_out = 'export {} = {} \\n ' . format ( key_to_set , value_out ) else : line_out = \" {} = {} \\n \" . format ( key_to_set , value_out ) with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ): replaced = False missing_newline = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) missing_newline = not mapping . original . string . endswith ( \" \\n \" ) if not replaced : if missing_newline : dest . write ( \" \\n \" ) dest . write ( line_out ) return True , key_to_set , value_to_set def unset_key ( dotenv_path : Union [ str , _PathLike ], key_to_unset : str , quote_mode : str = \"always\" , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional [ bool ], str ]: \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ): logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ): for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset def resolve_variables ( values : Iterable [ Tuple [ str , Optional [ str ]]], override : bool , ) -> Mapping [ str , Optional [ str ]]: new_values = {} # type: Dict[str, Optional[str]] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type: Dict[str, Optional[str]] if override : env . update ( os . environ ) # type: ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type: ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values def _walk_to_root ( path : str ) -> Iterator [ str ]: \"\"\" Yield directories starting from the given directory up to the root \"\"\" if not os . path . exists ( path ): raise IOError ( 'Starting path not found' ) if os . path . isfile ( path ): path = os . path . dirname ( path ) last_dir = None current_dir = os . path . abspath ( path ) while last_dir != current_dir : yield current_dir parent_dir = os . path . abspath ( os . path . join ( current_dir , os . path . pardir )) last_dir , current_dir = current_dir , parent_dir def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False , ) -> str : \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__, e.g. in REPL or IPython notebook. path = os . getcwd () else : # will work for .py files frame = sys . _getframe () current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ): check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ): return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return '' def load_dotenv ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> bool : \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: Text stream (such as `io.StringIO`) with .env content, used if `dotenv_path` is `None`. - *verbose*: whether to output a warning the .env file is missing. Defaults to `False`. - *override*: whether to override the system environment variables with the variables in `.env` file. Defaults to `False`. - *encoding*: encoding to be used to read the file. If both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () dotenv = DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = override , encoding = encoding , ) return dotenv . set_as_environment_variables () def dotenv_values ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> Dict [ str , Optional [ str ]]: \"\"\" Parse a .env file and return its content as a dict. The returned dict will have `None` values for keys without values in the .env file. For example, `foo=bar` results in `{\"foo\": \"bar\"}` whereas `foo` alone results in `{\"foo\": None}` Parameters: - `dotenv_path`: absolute or relative path to the .env file. - `stream`: `StringIO` object with .env content, used if `dotenv_path` is `None`. - `verbose`: whether to output a warning if the .env file is missing. Defaults to `False`. - `encoding`: encoding to be used to read the file. Defaults to `\"utf-8\"`. If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () return DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = True , encoding = encoding , ) . dict () Variables logger Functions dotenv_values def dotenv_values ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> Dict [ str , Optional [ str ]] Parse a .env file and return its content as a dict. The returned dict will have None values for keys without values in the .env file. For example, foo=bar results in {\"foo\": \"bar\"} whereas foo alone results in {\"foo\": None} Parameters: dotenv_path : absolute or relative path to the .env file. stream : StringIO object with .env content, used if dotenv_path is None . verbose : whether to output a warning if the .env file is missing. Defaults to False . encoding : encoding to be used to read the file. Defaults to \"utf-8\" . If both dotenv_path and stream are None , find_dotenv() is used to find the .env file. View Source def dotenv_values ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> Dict [ str , Optional [ str ]] : \" \"\" Parse a .env file and return its content as a dict. The returned dict will have `None` values for keys without values in the .env file. For example, `foo=bar` results in `{\" foo \": \" bar \"}` whereas `foo` alone results in `{\" foo \": None}` Parameters: - `dotenv_path`: absolute or relative path to the .env file. - `stream`: `StringIO` object with .env content, used if `dotenv_path` is `None`. - `verbose`: whether to output a warning if the .env file is missing. Defaults to `False`. - `encoding`: encoding to be used to read the file. Defaults to `\" utf - 8 \"`. If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the .env file. \"\" \" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () return DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = True , encoding = encoding , ). dict () find_dotenv def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False ) -> str Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False , ) -> str : \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive () : \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ) : # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ) : check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ) : return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return '' get_key def get_key ( dotenv_path : Union [ str , os . PathLike ], key_to_get : str , encoding : Optional [ str ] = 'utf-8' ) -> Optional [ str ] Get the value of a given key from the given .env. Returns None if the key isn't found or doesn't have a value. View Source def get_key ( dotenv_path : Union [ str, _PathLike ] , key_to_get : str , encoding : Optional [ str ] = \"utf-8\" , ) -> Optional [ str ] : \"\"\" Get the value of a given key from the given .env. Returns `None` if the key isn't found or doesn't have a value. \"\"\" return DotEnv ( dotenv_path , verbose = True , encoding = encoding ). get ( key_to_get ) load_dotenv def load_dotenv ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> bool Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : Text stream (such as io.StringIO ) with .env content, used if dotenv_path is None . verbose : whether to output a warning the .env file is missing. Defaults to False . override : whether to override the system environment variables with the variables in .env file. Defaults to False . encoding : encoding to be used to read the file. If both dotenv_path and stream , find_dotenv() is used to find the .env file. View Source def load_dotenv ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> bool : \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: Text stream (such as `io.StringIO`) with .env content, used if `dotenv_path` is `None`. - *verbose*: whether to output a warning the .env file is missing. Defaults to `False`. - *override*: whether to override the system environment variables with the variables in `.env` file. Defaults to `False`. - *encoding*: encoding to be used to read the file. If both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () dotenv = DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = override , encoding = encoding , ) return dotenv . set_as_environment_variables () resolve_variables def resolve_variables ( values : Iterable [ Tuple [ str , Optional [ str ]]], override : bool ) -> Mapping [ str , Optional [ str ]] View Source def resolve_variables ( values : Iterable [ Tuple[str, Optional[str ] ]] , override : bool , ) -> Mapping [ str, Optional[str ] ]: new_values = {} # type : Dict [ str, Optional[str ] ] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type : Dict [ str, Optional[str ] ] if override : env . update ( os . environ ) # type : ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type : ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values rewrite def rewrite ( path : Union [ str , os . PathLike ], encoding : Optional [ str ] ) -> Iterator [ Tuple [ IO [ str ], IO [ str ]]] View Source @contextmanager def rewrite ( path : Union [ str, _PathLike ] , encoding : Optional [ str ] , ) -> Iterator [ Tuple[IO[str ] , IO [ str ] ]]: try : if not os . path . isfile ( path ) : with open ( path , \"w+\" , encoding = encoding ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False , encoding = encoding ) as dest : with open ( path , encoding = encoding ) as source : yield ( source , dest ) # type : ignore except BaseException : if os . path . isfile ( dest . name ) : os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path ) set_key def set_key ( dotenv_path : Union [ str , os . PathLike ], key_to_set : str , value_to_set : str , quote_mode : str = 'always' , export : bool = False , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str , str ] Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path : Union [ str, _PathLike ] , key_to_set : str , value_to_set : str , quote_mode : str = \"always\" , export : bool = False , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str , str ]: \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" if quote_mode not in ( \"always\" , \"auto\" , \"never\" ) : raise ValueError ( \"Unknown quote_mode: {}\" . format ( quote_mode )) quote = ( quote_mode == \"always\" or ( quote_mode == \"auto\" and not value_to_set . isalnum ()) ) if quote : value_out = \"'{}'\" . format ( value_to_set . replace ( \"'\" , \"\\\\'\" )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : replaced = False missing_newline = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) missing_newline = not mapping . original . string . endswith ( \"\\n\" ) if not replaced : if missing_newline : dest . write ( \"\\n\" ) dest . write ( line_out ) return True , key_to_set , value_to_set unset_key def unset_key ( dotenv_path : Union [ str , os . PathLike ], key_to_unset : str , quote_mode : str = 'always' , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str ] Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path : Union [ str, _PathLike ] , key_to_unset : str , quote_mode : str = \"always\" , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str ]: \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset with_warn_for_invalid_lines def with_warn_for_invalid_lines ( mappings : Iterator [ dotenv . parser . Binding ] ) -> Iterator [ dotenv . parser . Binding ] View Source def with_warn_for_invalid_lines ( mappings : Iterator [ Binding ] ) -> Iterator [ Binding ] : for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s\" , mapping . original . line , ) yield mapping Classes DotEnv class DotEnv ( dotenv_path : Union [ str , os . PathLike , NoneType ], stream : Optional [ IO [ str ]] = None , verbose : bool = False , encoding : Optional [ str ] = None , interpolate : bool = True , override : bool = True ) View Source class DotEnv () : def __init__ ( self , dotenv_path : Optional [ Union[str, _PathLike ] ] , stream : Optional [ IO[str ] ] = None , verbose : bool = False , encoding : Union [ None, str ] = None , interpolate : bool = True , override : bool = True , ) -> None : self . dotenv_path = dotenv_path # type : Optional [ Union[str, _PathLike ] ] self . stream = stream # type : Optional [ IO[str ] ] self . _dict = None # type : Optional [ Dict[str, Optional[str ] ]] self . verbose = verbose # type : bool self . encoding = encoding # type : Union [ None, str ] self . interpolate = interpolate # type : bool self . override = override # type : bool @contextmanager def _get_stream ( self ) -> Iterator [ IO[str ] ]: if self . dotenv_path and os . path . isfile ( self . dotenv_path ) : with open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream elif self . stream is not None : yield self . stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s.\" , self . dotenv_path or '.env' , ) yield io . StringIO ( '' ) def dict ( self ) -> Dict [ str, Optional[str ] ]: \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ) -> Iterator [ Tuple[str, Optional[str ] ]]: with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ) -> bool : \"\"\" Load the current dotenv as system environment variable. \"\"\" for k , v in self . dict (). items () : if k in os . environ and not self . override : continue if v is not None : os . environ [ k ] = v return True def get ( self , key : str ) -> Optional [ str ] : \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None Methods dict def dict ( self ) -> Dict [ str , Optional [ str ]] Return dotenv as dict View Source def dict ( self ) -> Dict [ str, Optional[str ] ]: \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict get def get ( self , key : str ) -> Optional [ str ] View Source def get ( self , key : str ) -> Optional [ str ] : \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None parse def parse ( self ) -> Iterator [ Tuple [ str , Optional [ str ]]] View Source def parse ( self ) -> Iterator [ Tuple[str, Optional[str ] ]]: with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value set_as_environment_variables def set_as_environment_variables ( self ) -> bool Load the current dotenv as system environment variable. View Source def set_as_environment_variables ( self ) -> bool : \"\"\" Load the current dotenv as system environment variable. \"\"\" for k , v in self . dict (). items () : if k in os . environ and not self . override : continue if v is not None : os . environ [ k ] = v return True","title":"Main"},{"location":"reference/dotenv/main/#module-dotenvmain","text":"None None View Source import io import logging import os import shutil import sys import tempfile from collections import OrderedDict from contextlib import contextmanager from typing import ( IO , Dict , Iterable , Iterator , Mapping , Optional , Tuple , Union ) from .parser import Binding , parse_stream from .variables import parse_variables logger = logging . getLogger ( __name__ ) if sys . version_info >= ( 3 , 6 ): _PathLike = os . PathLike else : _PathLike = str def with_warn_for_invalid_lines ( mappings : Iterator [ Binding ]) -> Iterator [ Binding ]: for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s \" , mapping . original . line , ) yield mapping class DotEnv (): def __init__ ( self , dotenv_path : Optional [ Union [ str , _PathLike ]], stream : Optional [ IO [ str ]] = None , verbose : bool = False , encoding : Union [ None , str ] = None , interpolate : bool = True , override : bool = True , ) -> None : self . dotenv_path = dotenv_path # type: Optional[Union[str, _PathLike]] self . stream = stream # type: Optional[IO[str]] self . _dict = None # type: Optional[Dict[str, Optional[str]]] self . verbose = verbose # type: bool self . encoding = encoding # type: Union[None, str] self . interpolate = interpolate # type: bool self . override = override # type: bool @contextmanager def _get_stream ( self ) -> Iterator [ IO [ str ]]: if self . dotenv_path and os . path . isfile ( self . dotenv_path ): with open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream elif self . stream is not None : yield self . stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s .\" , self . dotenv_path or '.env' , ) yield io . StringIO ( '' ) def dict ( self ) -> Dict [ str , Optional [ str ]]: \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ) -> Iterator [ Tuple [ str , Optional [ str ]]]: with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )): if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ) -> bool : \"\"\" Load the current dotenv as system environment variable. \"\"\" for k , v in self . dict () . items (): if k in os . environ and not self . override : continue if v is not None : os . environ [ k ] = v return True def get ( self , key : str ) -> Optional [ str ]: \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s .\" , key , self . dotenv_path ) return None def get_key ( dotenv_path : Union [ str , _PathLike ], key_to_get : str , encoding : Optional [ str ] = \"utf-8\" , ) -> Optional [ str ]: \"\"\" Get the value of a given key from the given .env. Returns `None` if the key isn't found or doesn't have a value. \"\"\" return DotEnv ( dotenv_path , verbose = True , encoding = encoding ) . get ( key_to_get ) @contextmanager def rewrite ( path : Union [ str , _PathLike ], encoding : Optional [ str ], ) -> Iterator [ Tuple [ IO [ str ], IO [ str ]]]: try : if not os . path . isfile ( path ): with open ( path , \"w+\" , encoding = encoding ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False , encoding = encoding ) as dest : with open ( path , encoding = encoding ) as source : yield ( source , dest ) # type: ignore except BaseException : if os . path . isfile ( dest . name ): os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path ) def set_key ( dotenv_path : Union [ str , _PathLike ], key_to_set : str , value_to_set : str , quote_mode : str = \"always\" , export : bool = False , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional [ bool ], str , str ]: \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" if quote_mode not in ( \"always\" , \"auto\" , \"never\" ): raise ValueError ( \"Unknown quote_mode: {} \" . format ( quote_mode )) quote = ( quote_mode == \"always\" or ( quote_mode == \"auto\" and not value_to_set . isalnum ()) ) if quote : value_out = \"' {} '\" . format ( value_to_set . replace ( \"'\" , \" \\\\ '\" )) else : value_out = value_to_set if export : line_out = 'export {} = {} \\n ' . format ( key_to_set , value_out ) else : line_out = \" {} = {} \\n \" . format ( key_to_set , value_out ) with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ): replaced = False missing_newline = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) missing_newline = not mapping . original . string . endswith ( \" \\n \" ) if not replaced : if missing_newline : dest . write ( \" \\n \" ) dest . write ( line_out ) return True , key_to_set , value_to_set def unset_key ( dotenv_path : Union [ str , _PathLike ], key_to_unset : str , quote_mode : str = \"always\" , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional [ bool ], str ]: \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ): logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ): for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset def resolve_variables ( values : Iterable [ Tuple [ str , Optional [ str ]]], override : bool , ) -> Mapping [ str , Optional [ str ]]: new_values = {} # type: Dict[str, Optional[str]] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type: Dict[str, Optional[str]] if override : env . update ( os . environ ) # type: ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type: ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values def _walk_to_root ( path : str ) -> Iterator [ str ]: \"\"\" Yield directories starting from the given directory up to the root \"\"\" if not os . path . exists ( path ): raise IOError ( 'Starting path not found' ) if os . path . isfile ( path ): path = os . path . dirname ( path ) last_dir = None current_dir = os . path . abspath ( path ) while last_dir != current_dir : yield current_dir parent_dir = os . path . abspath ( os . path . join ( current_dir , os . path . pardir )) last_dir , current_dir = current_dir , parent_dir def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False , ) -> str : \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__, e.g. in REPL or IPython notebook. path = os . getcwd () else : # will work for .py files frame = sys . _getframe () current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ): check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ): return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return '' def load_dotenv ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> bool : \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: Text stream (such as `io.StringIO`) with .env content, used if `dotenv_path` is `None`. - *verbose*: whether to output a warning the .env file is missing. Defaults to `False`. - *override*: whether to override the system environment variables with the variables in `.env` file. Defaults to `False`. - *encoding*: encoding to be used to read the file. If both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () dotenv = DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = override , encoding = encoding , ) return dotenv . set_as_environment_variables () def dotenv_values ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> Dict [ str , Optional [ str ]]: \"\"\" Parse a .env file and return its content as a dict. The returned dict will have `None` values for keys without values in the .env file. For example, `foo=bar` results in `{\"foo\": \"bar\"}` whereas `foo` alone results in `{\"foo\": None}` Parameters: - `dotenv_path`: absolute or relative path to the .env file. - `stream`: `StringIO` object with .env content, used if `dotenv_path` is `None`. - `verbose`: whether to output a warning if the .env file is missing. Defaults to `False`. - `encoding`: encoding to be used to read the file. Defaults to `\"utf-8\"`. If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () return DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = True , encoding = encoding , ) . dict ()","title":"Module dotenv.main"},{"location":"reference/dotenv/main/#variables","text":"logger","title":"Variables"},{"location":"reference/dotenv/main/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/main/#dotenv_values","text":"def dotenv_values ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> Dict [ str , Optional [ str ]] Parse a .env file and return its content as a dict. The returned dict will have None values for keys without values in the .env file. For example, foo=bar results in {\"foo\": \"bar\"} whereas foo alone results in {\"foo\": None} Parameters: dotenv_path : absolute or relative path to the .env file. stream : StringIO object with .env content, used if dotenv_path is None . verbose : whether to output a warning if the .env file is missing. Defaults to False . encoding : encoding to be used to read the file. Defaults to \"utf-8\" . If both dotenv_path and stream are None , find_dotenv() is used to find the .env file. View Source def dotenv_values ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> Dict [ str , Optional [ str ]] : \" \"\" Parse a .env file and return its content as a dict. The returned dict will have `None` values for keys without values in the .env file. For example, `foo=bar` results in `{\" foo \": \" bar \"}` whereas `foo` alone results in `{\" foo \": None}` Parameters: - `dotenv_path`: absolute or relative path to the .env file. - `stream`: `StringIO` object with .env content, used if `dotenv_path` is `None`. - `verbose`: whether to output a warning if the .env file is missing. Defaults to `False`. - `encoding`: encoding to be used to read the file. Defaults to `\" utf - 8 \"`. If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the .env file. \"\" \" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () return DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = True , encoding = encoding , ). dict ()","title":"dotenv_values"},{"location":"reference/dotenv/main/#find_dotenv","text":"def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False ) -> str Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename : str = '.env' , raise_error_if_not_found : bool = False , usecwd : bool = False , ) -> str : \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive () : \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ) : # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ) : check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ) : return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return ''","title":"find_dotenv"},{"location":"reference/dotenv/main/#get_key","text":"def get_key ( dotenv_path : Union [ str , os . PathLike ], key_to_get : str , encoding : Optional [ str ] = 'utf-8' ) -> Optional [ str ] Get the value of a given key from the given .env. Returns None if the key isn't found or doesn't have a value. View Source def get_key ( dotenv_path : Union [ str, _PathLike ] , key_to_get : str , encoding : Optional [ str ] = \"utf-8\" , ) -> Optional [ str ] : \"\"\" Get the value of a given key from the given .env. Returns `None` if the key isn't found or doesn't have a value. \"\"\" return DotEnv ( dotenv_path , verbose = True , encoding = encoding ). get ( key_to_get )","title":"get_key"},{"location":"reference/dotenv/main/#load_dotenv","text":"def load_dotenv ( dotenv_path : Union [ str , os . PathLike , NoneType ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = 'utf-8' ) -> bool Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : Text stream (such as io.StringIO ) with .env content, used if dotenv_path is None . verbose : whether to output a warning the .env file is missing. Defaults to False . override : whether to override the system environment variables with the variables in .env file. Defaults to False . encoding : encoding to be used to read the file. If both dotenv_path and stream , find_dotenv() is used to find the .env file. View Source def load_dotenv ( dotenv_path : Union [ str , _PathLike , None ] = None , stream : Optional [ IO [ str ]] = None , verbose : bool = False , override : bool = False , interpolate : bool = True , encoding : Optional [ str ] = \"utf-8\" , ) -> bool : \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: Text stream (such as `io.StringIO`) with .env content, used if `dotenv_path` is `None`. - *verbose*: whether to output a warning the .env file is missing. Defaults to `False`. - *override*: whether to override the system environment variables with the variables in `.env` file. Defaults to `False`. - *encoding*: encoding to be used to read the file. If both `dotenv_path` and `stream`, `find_dotenv()` is used to find the .env file. \"\"\" if dotenv_path is None and stream is None : dotenv_path = find_dotenv () dotenv = DotEnv ( dotenv_path = dotenv_path , stream = stream , verbose = verbose , interpolate = interpolate , override = override , encoding = encoding , ) return dotenv . set_as_environment_variables ()","title":"load_dotenv"},{"location":"reference/dotenv/main/#resolve_variables","text":"def resolve_variables ( values : Iterable [ Tuple [ str , Optional [ str ]]], override : bool ) -> Mapping [ str , Optional [ str ]] View Source def resolve_variables ( values : Iterable [ Tuple[str, Optional[str ] ]] , override : bool , ) -> Mapping [ str, Optional[str ] ]: new_values = {} # type : Dict [ str, Optional[str ] ] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type : Dict [ str, Optional[str ] ] if override : env . update ( os . environ ) # type : ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type : ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values","title":"resolve_variables"},{"location":"reference/dotenv/main/#rewrite","text":"def rewrite ( path : Union [ str , os . PathLike ], encoding : Optional [ str ] ) -> Iterator [ Tuple [ IO [ str ], IO [ str ]]] View Source @contextmanager def rewrite ( path : Union [ str, _PathLike ] , encoding : Optional [ str ] , ) -> Iterator [ Tuple[IO[str ] , IO [ str ] ]]: try : if not os . path . isfile ( path ) : with open ( path , \"w+\" , encoding = encoding ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False , encoding = encoding ) as dest : with open ( path , encoding = encoding ) as source : yield ( source , dest ) # type : ignore except BaseException : if os . path . isfile ( dest . name ) : os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path )","title":"rewrite"},{"location":"reference/dotenv/main/#set_key","text":"def set_key ( dotenv_path : Union [ str , os . PathLike ], key_to_set : str , value_to_set : str , quote_mode : str = 'always' , export : bool = False , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str , str ] Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path : Union [ str, _PathLike ] , key_to_set : str , value_to_set : str , quote_mode : str = \"always\" , export : bool = False , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str , str ]: \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" if quote_mode not in ( \"always\" , \"auto\" , \"never\" ) : raise ValueError ( \"Unknown quote_mode: {}\" . format ( quote_mode )) quote = ( quote_mode == \"always\" or ( quote_mode == \"auto\" and not value_to_set . isalnum ()) ) if quote : value_out = \"'{}'\" . format ( value_to_set . replace ( \"'\" , \"\\\\'\" )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : replaced = False missing_newline = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) missing_newline = not mapping . original . string . endswith ( \"\\n\" ) if not replaced : if missing_newline : dest . write ( \"\\n\" ) dest . write ( line_out ) return True , key_to_set , value_to_set","title":"set_key"},{"location":"reference/dotenv/main/#unset_key","text":"def unset_key ( dotenv_path : Union [ str , os . PathLike ], key_to_unset : str , quote_mode : str = 'always' , encoding : Optional [ str ] = 'utf-8' ) -> Tuple [ Optional [ bool ], str ] Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path : Union [ str, _PathLike ] , key_to_unset : str , quote_mode : str = \"always\" , encoding : Optional [ str ] = \"utf-8\" , ) -> Tuple [ Optional[bool ] , str ]: \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path , encoding = encoding ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset","title":"unset_key"},{"location":"reference/dotenv/main/#with_warn_for_invalid_lines","text":"def with_warn_for_invalid_lines ( mappings : Iterator [ dotenv . parser . Binding ] ) -> Iterator [ dotenv . parser . Binding ] View Source def with_warn_for_invalid_lines ( mappings : Iterator [ Binding ] ) -> Iterator [ Binding ] : for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s\" , mapping . original . line , ) yield mapping","title":"with_warn_for_invalid_lines"},{"location":"reference/dotenv/main/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/main/#dotenv","text":"class DotEnv ( dotenv_path : Union [ str , os . PathLike , NoneType ], stream : Optional [ IO [ str ]] = None , verbose : bool = False , encoding : Optional [ str ] = None , interpolate : bool = True , override : bool = True ) View Source class DotEnv () : def __init__ ( self , dotenv_path : Optional [ Union[str, _PathLike ] ] , stream : Optional [ IO[str ] ] = None , verbose : bool = False , encoding : Union [ None, str ] = None , interpolate : bool = True , override : bool = True , ) -> None : self . dotenv_path = dotenv_path # type : Optional [ Union[str, _PathLike ] ] self . stream = stream # type : Optional [ IO[str ] ] self . _dict = None # type : Optional [ Dict[str, Optional[str ] ]] self . verbose = verbose # type : bool self . encoding = encoding # type : Union [ None, str ] self . interpolate = interpolate # type : bool self . override = override # type : bool @contextmanager def _get_stream ( self ) -> Iterator [ IO[str ] ]: if self . dotenv_path and os . path . isfile ( self . dotenv_path ) : with open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream elif self . stream is not None : yield self . stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s.\" , self . dotenv_path or '.env' , ) yield io . StringIO ( '' ) def dict ( self ) -> Dict [ str, Optional[str ] ]: \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ) -> Iterator [ Tuple[str, Optional[str ] ]]: with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ) -> bool : \"\"\" Load the current dotenv as system environment variable. \"\"\" for k , v in self . dict (). items () : if k in os . environ and not self . override : continue if v is not None : os . environ [ k ] = v return True def get ( self , key : str ) -> Optional [ str ] : \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None","title":"DotEnv"},{"location":"reference/dotenv/main/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/main/#dict","text":"def dict ( self ) -> Dict [ str , Optional [ str ]] Return dotenv as dict View Source def dict ( self ) -> Dict [ str, Optional[str ] ]: \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict","title":"dict"},{"location":"reference/dotenv/main/#get","text":"def get ( self , key : str ) -> Optional [ str ] View Source def get ( self , key : str ) -> Optional [ str ] : \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None","title":"get"},{"location":"reference/dotenv/main/#parse","text":"def parse ( self ) -> Iterator [ Tuple [ str , Optional [ str ]]] View Source def parse ( self ) -> Iterator [ Tuple[str, Optional[str ] ]]: with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value","title":"parse"},{"location":"reference/dotenv/main/#set_as_environment_variables","text":"def set_as_environment_variables ( self ) -> bool Load the current dotenv as system environment variable. View Source def set_as_environment_variables ( self ) -> bool : \"\"\" Load the current dotenv as system environment variable. \"\"\" for k , v in self . dict (). items () : if k in os . environ and not self . override : continue if v is not None : os . environ [ k ] = v return True","title":"set_as_environment_variables"},{"location":"reference/dotenv/parser/","text":"Module dotenv.parser None None View Source import codecs import re from typing import ( IO , Iterator , Match , NamedTuple , Optional , # noqa:F401 Pattern , Sequence , Tuple ) def make_regex ( string : str , extra_flags : int = 0 ) -> Pattern [ str ]: return re . compile ( string , re . UNICODE | extra_flags ) _newline = make_regex ( r \"(\\r\\n|\\n|\\r)\" ) _multiline_whitespace = make_regex ( r \"\\s*\" , extra_flags = re . MULTILINE ) _whitespace = make_regex ( r \"[^\\S\\r\\n]*\" ) _export = make_regex ( r \"(?:export[^\\S\\r\\n]+)?\" ) _single_quoted_key = make_regex ( r \"'([^']+)'\" ) _unquoted_key = make_regex ( r \"([^=\\#\\s]+)\" ) _equal_sign = make_regex ( r \"(=[^\\S\\r\\n]*)\" ) _single_quoted_value = make_regex ( r \"'((?: \\\\ '|[^'])*)'\" ) _double_quoted_value = make_regex ( r '\"((?: \\\\ \"|[^\"])*)\"' ) _unquoted_value = make_regex ( r \"([^\\r\\n]*)\" ) _comment = make_regex ( r \"(?:[^\\S\\r\\n]*#[^\\r\\n]*)?\" ) _end_of_line = make_regex ( r \"[^\\S\\r\\n]*(?:\\r\\n|\\n|\\r|$)\" ) _rest_of_line = make_regex ( r \"[^\\r\\n]*(?:\\r|\\n|\\r\\n)?\" ) _double_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ' \\\" abfnrtv]\" ) _single_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ']\" ) Original = NamedTuple ( \"Original\" , [ ( \"string\" , str ), ( \"line\" , int ), ], ) Binding = NamedTuple ( \"Binding\" , [ ( \"key\" , Optional [ str ]), ( \"value\" , Optional [ str ]), ( \"original\" , Original ), ( \"error\" , bool ), ], ) class Position : def __init__ ( self , chars : int , line : int ) -> None : self . chars = chars self . line = line @classmethod def start ( cls ) -> \"Position\" : return cls ( chars = 0 , line = 1 ) def set ( self , other : \"Position\" ) -> None : self . chars = other . chars self . line = other . line def advance ( self , string : str ) -> None : self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) class Error ( Exception ): pass class Reader : def __init__ ( self , stream : IO [ str ]) -> None : self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ) -> bool : return self . position . chars < len ( self . string ) def set_mark ( self ) -> None : self . mark . set ( self . position ) def get_marked ( self ) -> Original : return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , ) def peek ( self , count : int ) -> str : return self . string [ self . position . chars : self . position . chars + count ] def read ( self , count : int ) -> str : result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex : Pattern [ str ]) -> Sequence [ str ]: match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match . start (): match . end ()]) return match . groups () def decode_escapes ( regex : Pattern [ str ], string : str ) -> str : def decode_match ( match : Match [ str ]) -> str : return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type: ignore return regex . sub ( decode_match , string ) def parse_key ( reader : Reader ) -> Optional [ str ]: char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key def parse_unquoted_value ( reader : Reader ) -> str : ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ) . rstrip () def parse_value ( reader : Reader ) -> str : char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ): return u \"\" else : return parse_unquoted_value ( reader ) def parse_binding ( reader : Reader ) -> Binding : reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next (): return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type: Optional[str] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , ) def parse_stream ( stream : IO [ str ]) -> Iterator [ Binding ]: reader = Reader ( stream ) while reader . has_next (): yield parse_binding ( reader ) Functions decode_escapes def decode_escapes ( regex : Pattern [ str ], string : str ) -> str View Source def decode_escapes ( regex : Pattern [ str ] , string : str ) -> str : def decode_match ( match : Match [ str ] ) -> str : return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type : ignore return regex . sub ( decode_match , string ) make_regex def make_regex ( string : str , extra_flags : int = 0 ) -> Pattern [ str ] View Source def make_regex ( string : str , extra_flags : int = 0 ) -> Pattern [ str ] : return re . compile ( string , re . UNICODE | extra_flags ) parse_binding def parse_binding ( reader : dotenv . parser . Reader ) -> dotenv . parser . Binding View Source def parse_binding ( reader : Reader ) -> Binding : reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next () : return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type : Optional [ str ] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , ) parse_key def parse_key ( reader : dotenv . parser . Reader ) -> Optional [ str ] View Source def parse_key ( reader : Reader ) -> Optional [ str ] : char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key parse_stream def parse_stream ( stream : IO [ str ] ) -> Iterator [ dotenv . parser . Binding ] View Source def parse_stream ( stream : IO [ str ] ) -> Iterator [ Binding ] : reader = Reader ( stream ) while reader . has_next () : yield parse_binding ( reader ) parse_unquoted_value def parse_unquoted_value ( reader : dotenv . parser . Reader ) -> str View Source def parse_unquoted_value ( reader: Reader ) -> str: ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ). rstrip () parse_value def parse_value ( reader : dotenv . parser . Reader ) -> str View Source def parse_value ( reader: Reader ) -> str: char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ) : return u \"\" else : return parse_unquoted_value ( reader ) Classes Binding class Binding ( / , * args , ** kwargs ) Ancestors (in MRO) builtins.tuple Class variables error key original value Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. Error class Error ( / , * args , ** kwargs ) View Source class Error ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. Original class Original ( / , * args , ** kwargs ) Ancestors (in MRO) builtins.tuple Class variables line string Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. Position class Position ( chars : int , line : int ) View Source class Position : def __init__ ( self , chars : int , line : int ) -> None : self . chars = chars self . line = line @classmethod def start ( cls ) -> \"Position\" : return cls ( chars = 0 , line = 1 ) def set ( self , other : \"Position\" ) -> None : self . chars = other . chars self . line = other . line def advance ( self , string : str ) -> None : self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) Static methods start def start ( ) -> 'Position' View Source @classmethod def start ( cls ) -> \"Position\" : return cls ( chars = 0 , line = 1 ) Methods advance def advance ( self , string : str ) -> None View Source def advance ( self , string : str ) -> None : self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) set def set ( self , other : 'Position' ) -> None View Source def set ( self , other : \"Position\" ) -> None : self . chars = other . chars self . line = other . line Reader class Reader ( stream : IO [ str ] ) View Source class Reader : def __init__ ( self , stream : IO [ str ] ) -> None : self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ) -> bool : return self . position . chars < len ( self . string ) def set_mark ( self ) -> None : self . mark . set ( self . position ) def get_marked ( self ) -> Original : return Original ( string = self . string [ self.mark.chars:self.position.chars ] , line = self . mark . line , ) def peek ( self , count : int ) -> str : return self . string [ self.position.chars:self.position.chars + count ] def read ( self , count : int ) -> str : result = self . string [ self.position.chars:self.position.chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex : Pattern [ str ] ) -> Sequence [ str ] : match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups () Methods get_marked def get_marked ( self ) -> dotenv . parser . Original View Source def get_marked ( self ) -> Original : return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , ) has_next def has_next ( self ) -> bool View Source def has_next ( self ) -> bool : return self . position . chars < len ( self . string ) peek def peek ( self , count : int ) -> str View Source def peek ( self , count : int ) -> str : return self . string [ self . position . chars : self . position . chars + count ] read def read ( self , count : int ) -> str View Source def read ( self , count : int ) -> str : result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result read_regex def read_regex ( self , regex : Pattern [ str ] ) -> Sequence [ str ] View Source def read_regex ( self , regex : Pattern [ str ] ) -> Sequence [ str ] : match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups () set_mark def set_mark ( self ) -> None View Source def set_mark ( self ) -> None : self . mark . set ( self . position )","title":"Parser"},{"location":"reference/dotenv/parser/#module-dotenvparser","text":"None None View Source import codecs import re from typing import ( IO , Iterator , Match , NamedTuple , Optional , # noqa:F401 Pattern , Sequence , Tuple ) def make_regex ( string : str , extra_flags : int = 0 ) -> Pattern [ str ]: return re . compile ( string , re . UNICODE | extra_flags ) _newline = make_regex ( r \"(\\r\\n|\\n|\\r)\" ) _multiline_whitespace = make_regex ( r \"\\s*\" , extra_flags = re . MULTILINE ) _whitespace = make_regex ( r \"[^\\S\\r\\n]*\" ) _export = make_regex ( r \"(?:export[^\\S\\r\\n]+)?\" ) _single_quoted_key = make_regex ( r \"'([^']+)'\" ) _unquoted_key = make_regex ( r \"([^=\\#\\s]+)\" ) _equal_sign = make_regex ( r \"(=[^\\S\\r\\n]*)\" ) _single_quoted_value = make_regex ( r \"'((?: \\\\ '|[^'])*)'\" ) _double_quoted_value = make_regex ( r '\"((?: \\\\ \"|[^\"])*)\"' ) _unquoted_value = make_regex ( r \"([^\\r\\n]*)\" ) _comment = make_regex ( r \"(?:[^\\S\\r\\n]*#[^\\r\\n]*)?\" ) _end_of_line = make_regex ( r \"[^\\S\\r\\n]*(?:\\r\\n|\\n|\\r|$)\" ) _rest_of_line = make_regex ( r \"[^\\r\\n]*(?:\\r|\\n|\\r\\n)?\" ) _double_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ' \\\" abfnrtv]\" ) _single_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ']\" ) Original = NamedTuple ( \"Original\" , [ ( \"string\" , str ), ( \"line\" , int ), ], ) Binding = NamedTuple ( \"Binding\" , [ ( \"key\" , Optional [ str ]), ( \"value\" , Optional [ str ]), ( \"original\" , Original ), ( \"error\" , bool ), ], ) class Position : def __init__ ( self , chars : int , line : int ) -> None : self . chars = chars self . line = line @classmethod def start ( cls ) -> \"Position\" : return cls ( chars = 0 , line = 1 ) def set ( self , other : \"Position\" ) -> None : self . chars = other . chars self . line = other . line def advance ( self , string : str ) -> None : self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) class Error ( Exception ): pass class Reader : def __init__ ( self , stream : IO [ str ]) -> None : self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ) -> bool : return self . position . chars < len ( self . string ) def set_mark ( self ) -> None : self . mark . set ( self . position ) def get_marked ( self ) -> Original : return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , ) def peek ( self , count : int ) -> str : return self . string [ self . position . chars : self . position . chars + count ] def read ( self , count : int ) -> str : result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex : Pattern [ str ]) -> Sequence [ str ]: match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match . start (): match . end ()]) return match . groups () def decode_escapes ( regex : Pattern [ str ], string : str ) -> str : def decode_match ( match : Match [ str ]) -> str : return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type: ignore return regex . sub ( decode_match , string ) def parse_key ( reader : Reader ) -> Optional [ str ]: char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key def parse_unquoted_value ( reader : Reader ) -> str : ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ) . rstrip () def parse_value ( reader : Reader ) -> str : char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ): return u \"\" else : return parse_unquoted_value ( reader ) def parse_binding ( reader : Reader ) -> Binding : reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next (): return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type: Optional[str] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , ) def parse_stream ( stream : IO [ str ]) -> Iterator [ Binding ]: reader = Reader ( stream ) while reader . has_next (): yield parse_binding ( reader )","title":"Module dotenv.parser"},{"location":"reference/dotenv/parser/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/parser/#decode_escapes","text":"def decode_escapes ( regex : Pattern [ str ], string : str ) -> str View Source def decode_escapes ( regex : Pattern [ str ] , string : str ) -> str : def decode_match ( match : Match [ str ] ) -> str : return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type : ignore return regex . sub ( decode_match , string )","title":"decode_escapes"},{"location":"reference/dotenv/parser/#make_regex","text":"def make_regex ( string : str , extra_flags : int = 0 ) -> Pattern [ str ] View Source def make_regex ( string : str , extra_flags : int = 0 ) -> Pattern [ str ] : return re . compile ( string , re . UNICODE | extra_flags )","title":"make_regex"},{"location":"reference/dotenv/parser/#parse_binding","text":"def parse_binding ( reader : dotenv . parser . Reader ) -> dotenv . parser . Binding View Source def parse_binding ( reader : Reader ) -> Binding : reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next () : return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type : Optional [ str ] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , )","title":"parse_binding"},{"location":"reference/dotenv/parser/#parse_key","text":"def parse_key ( reader : dotenv . parser . Reader ) -> Optional [ str ] View Source def parse_key ( reader : Reader ) -> Optional [ str ] : char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key","title":"parse_key"},{"location":"reference/dotenv/parser/#parse_stream","text":"def parse_stream ( stream : IO [ str ] ) -> Iterator [ dotenv . parser . Binding ] View Source def parse_stream ( stream : IO [ str ] ) -> Iterator [ Binding ] : reader = Reader ( stream ) while reader . has_next () : yield parse_binding ( reader )","title":"parse_stream"},{"location":"reference/dotenv/parser/#parse_unquoted_value","text":"def parse_unquoted_value ( reader : dotenv . parser . Reader ) -> str View Source def parse_unquoted_value ( reader: Reader ) -> str: ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ). rstrip ()","title":"parse_unquoted_value"},{"location":"reference/dotenv/parser/#parse_value","text":"def parse_value ( reader : dotenv . parser . Reader ) -> str View Source def parse_value ( reader: Reader ) -> str: char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ) : return u \"\" else : return parse_unquoted_value ( reader )","title":"parse_value"},{"location":"reference/dotenv/parser/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/parser/#binding","text":"class Binding ( / , * args , ** kwargs )","title":"Binding"},{"location":"reference/dotenv/parser/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/parser/#class-variables","text":"error key original value","title":"Class variables"},{"location":"reference/dotenv/parser/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/dotenv/parser/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/dotenv/parser/#error","text":"class Error ( / , * args , ** kwargs ) View Source class Error ( Exception ): pass","title":"Error"},{"location":"reference/dotenv/parser/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/parser/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/dotenv/parser/#methods_1","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dotenv/parser/#original","text":"class Original ( / , * args , ** kwargs )","title":"Original"},{"location":"reference/dotenv/parser/#ancestors-in-mro_2","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/parser/#class-variables_2","text":"line string","title":"Class variables"},{"location":"reference/dotenv/parser/#methods_2","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#count_1","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/dotenv/parser/#index_1","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/dotenv/parser/#position","text":"class Position ( chars : int , line : int ) View Source class Position : def __init__ ( self , chars : int , line : int ) -> None : self . chars = chars self . line = line @classmethod def start ( cls ) -> \"Position\" : return cls ( chars = 0 , line = 1 ) def set ( self , other : \"Position\" ) -> None : self . chars = other . chars self . line = other . line def advance ( self , string : str ) -> None : self . chars += len ( string ) self . line += len ( re . findall ( _newline , string ))","title":"Position"},{"location":"reference/dotenv/parser/#static-methods","text":"","title":"Static methods"},{"location":"reference/dotenv/parser/#start","text":"def start ( ) -> 'Position' View Source @classmethod def start ( cls ) -> \"Position\" : return cls ( chars = 0 , line = 1 )","title":"start"},{"location":"reference/dotenv/parser/#methods_3","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#advance","text":"def advance ( self , string : str ) -> None View Source def advance ( self , string : str ) -> None : self . chars += len ( string ) self . line += len ( re . findall ( _newline , string ))","title":"advance"},{"location":"reference/dotenv/parser/#set","text":"def set ( self , other : 'Position' ) -> None View Source def set ( self , other : \"Position\" ) -> None : self . chars = other . chars self . line = other . line","title":"set"},{"location":"reference/dotenv/parser/#reader","text":"class Reader ( stream : IO [ str ] ) View Source class Reader : def __init__ ( self , stream : IO [ str ] ) -> None : self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ) -> bool : return self . position . chars < len ( self . string ) def set_mark ( self ) -> None : self . mark . set ( self . position ) def get_marked ( self ) -> Original : return Original ( string = self . string [ self.mark.chars:self.position.chars ] , line = self . mark . line , ) def peek ( self , count : int ) -> str : return self . string [ self.position.chars:self.position.chars + count ] def read ( self , count : int ) -> str : result = self . string [ self.position.chars:self.position.chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex : Pattern [ str ] ) -> Sequence [ str ] : match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups ()","title":"Reader"},{"location":"reference/dotenv/parser/#methods_4","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#get_marked","text":"def get_marked ( self ) -> dotenv . parser . Original View Source def get_marked ( self ) -> Original : return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , )","title":"get_marked"},{"location":"reference/dotenv/parser/#has_next","text":"def has_next ( self ) -> bool View Source def has_next ( self ) -> bool : return self . position . chars < len ( self . string )","title":"has_next"},{"location":"reference/dotenv/parser/#peek","text":"def peek ( self , count : int ) -> str View Source def peek ( self , count : int ) -> str : return self . string [ self . position . chars : self . position . chars + count ]","title":"peek"},{"location":"reference/dotenv/parser/#read","text":"def read ( self , count : int ) -> str View Source def read ( self , count : int ) -> str : result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result","title":"read"},{"location":"reference/dotenv/parser/#read_regex","text":"def read_regex ( self , regex : Pattern [ str ] ) -> Sequence [ str ] View Source def read_regex ( self , regex : Pattern [ str ] ) -> Sequence [ str ] : match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups ()","title":"read_regex"},{"location":"reference/dotenv/parser/#set_mark","text":"def set_mark ( self ) -> None View Source def set_mark ( self ) -> None : self . mark . set ( self . position )","title":"set_mark"},{"location":"reference/dotenv/variables/","text":"Module dotenv.variables None None View Source import re from abc import ABCMeta from typing import Iterator , Mapping , Optional , Pattern _ posix_variable = re . compile ( r \"\" \" \\ $ \\ { ( ? P < name > [ ^\\ } : ] * ) ( ?::- ( ? P < default > [ ^\\ }] * ) ) ? \\ } \"\"\", re.VERBOSE, ) # type: Pattern[str] class Atom(): __metaclass__ = ABCMeta def __ne__(self, other: object) -> bool: result = self.__eq__(other) if result is NotImplemented: return NotImplemented return not result def resolve(self, env: Mapping[str, Optional[str]]) -> str: raise NotImplementedError class Literal(Atom): def __init__(self, value: str) -> None: self.value = value def __repr__(self) -> str: return \" Literal ( value= {}) \".format(self.value) def __eq__(self, other: object) -> bool: if not isinstance(other, self.__class__): return NotImplemented return self.value == other.value def __hash__(self) -> int: return hash((self.__class__, self.value)) def resolve(self, env: Mapping[str, Optional[str]]) -> str: return self.value class Variable(Atom): def __init__(self, name: str, default: Optional[str]) -> None: self.name = name self.default = default def __repr__(self) -> str: return \" Variable ( name= {}, default= {}) \".format(self.name, self.default) def __eq__(self, other: object) -> bool: if not isinstance(other, self.__class__): return NotImplemented return (self.name, self.default) == (other.name, other.default) def __hash__(self) -> int: return hash((self.__class__, self.name, self.default)) def resolve(self, env: Mapping[str, Optional[str]]) -> str: default = self.default if self.default is not None else \"\" result = env.get(self.name, default) return result if result is not None else \"\" def parse_variables(value: str) -> Iterator[Atom]: cursor = 0 for match in _posix_variable.finditer(value): (start, end) = match.span() name = match.groupdict()[\" name \"] default = match.groupdict()[\" default \" ] if start > cursor : yield Literal ( value = value [ cursor : start ]) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor : length ]) Functions parse_variables def parse_variables ( value : str ) -> Iterator [ dotenv . variables . Atom ] View Source def parse_variables ( value : str ) -> Iterator [ Atom ] : cursor = 0 for match in _posix_variable . finditer ( value ) : ( start , end ) = match . span () name = match . groupdict () [ \"name\" ] default = match . groupdict () [ \"default\" ] if start > cursor : yield Literal ( value = value [ cursor:start ] ) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor:length ] ) Classes Atom class Atom ( / , * args , ** kwargs ) View Source class Atom () : __metaclass__ = ABCMeta def __ne__ ( self , other : object ) -> bool : result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : raise NotImplementedError Descendants dotenv.variables.Literal dotenv.variables.Variable Methods resolve def resolve ( self , env : Mapping [ str , Optional [ str ]] ) -> str View Source def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : raise NotImplementedError Literal class Literal ( value : str ) View Source class Literal ( Atom ) : def __init__ ( self , value : str ) -> None : self . value = value def __repr__ ( self ) -> str : return \"Literal(value={})\" . format ( self . value ) def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , self . __class__ ) : return NotImplemented return self . value == other . value def __hash__ ( self ) -> int : return hash (( self . __class__ , self . value )) def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : return self . value Ancestors (in MRO) dotenv.variables.Atom Methods resolve def resolve ( self , env : Mapping [ str , Optional [ str ]] ) -> str View Source def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : return self . value Variable class Variable ( name : str , default : Optional [ str ] ) View Source class Variable ( Atom ) : def __init__ ( self , name : str , default : Optional [ str ] ) -> None : self . name = name self . default = default def __repr__ ( self ) -> str : return \"Variable(name={}, default={})\" . format ( self . name , self . default ) def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , self . __class__ ) : return NotImplemented return ( self . name , self . default ) == ( other . name , other . default ) def __hash__ ( self ) -> int : return hash (( self . __class__ , self . name , self . default )) def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\" Ancestors (in MRO) dotenv.variables.Atom Methods resolve def resolve ( self , env : Mapping [ str , Optional [ str ]] ) -> str View Source def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\"","title":"Variables"},{"location":"reference/dotenv/variables/#module-dotenvvariables","text":"None None View Source import re from abc import ABCMeta from typing import Iterator , Mapping , Optional , Pattern _ posix_variable = re . compile ( r \"\" \" \\ $ \\ { ( ? P < name > [ ^\\ } : ] * ) ( ?::- ( ? P < default > [ ^\\ }] * ) ) ? \\ } \"\"\", re.VERBOSE, ) # type: Pattern[str] class Atom(): __metaclass__ = ABCMeta def __ne__(self, other: object) -> bool: result = self.__eq__(other) if result is NotImplemented: return NotImplemented return not result def resolve(self, env: Mapping[str, Optional[str]]) -> str: raise NotImplementedError class Literal(Atom): def __init__(self, value: str) -> None: self.value = value def __repr__(self) -> str: return \" Literal ( value= {}) \".format(self.value) def __eq__(self, other: object) -> bool: if not isinstance(other, self.__class__): return NotImplemented return self.value == other.value def __hash__(self) -> int: return hash((self.__class__, self.value)) def resolve(self, env: Mapping[str, Optional[str]]) -> str: return self.value class Variable(Atom): def __init__(self, name: str, default: Optional[str]) -> None: self.name = name self.default = default def __repr__(self) -> str: return \" Variable ( name= {}, default= {}) \".format(self.name, self.default) def __eq__(self, other: object) -> bool: if not isinstance(other, self.__class__): return NotImplemented return (self.name, self.default) == (other.name, other.default) def __hash__(self) -> int: return hash((self.__class__, self.name, self.default)) def resolve(self, env: Mapping[str, Optional[str]]) -> str: default = self.default if self.default is not None else \"\" result = env.get(self.name, default) return result if result is not None else \"\" def parse_variables(value: str) -> Iterator[Atom]: cursor = 0 for match in _posix_variable.finditer(value): (start, end) = match.span() name = match.groupdict()[\" name \"] default = match.groupdict()[\" default \" ] if start > cursor : yield Literal ( value = value [ cursor : start ]) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor : length ])","title":"Module dotenv.variables"},{"location":"reference/dotenv/variables/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/variables/#parse_variables","text":"def parse_variables ( value : str ) -> Iterator [ dotenv . variables . Atom ] View Source def parse_variables ( value : str ) -> Iterator [ Atom ] : cursor = 0 for match in _posix_variable . finditer ( value ) : ( start , end ) = match . span () name = match . groupdict () [ \"name\" ] default = match . groupdict () [ \"default\" ] if start > cursor : yield Literal ( value = value [ cursor:start ] ) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor:length ] )","title":"parse_variables"},{"location":"reference/dotenv/variables/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/variables/#atom","text":"class Atom ( / , * args , ** kwargs ) View Source class Atom () : __metaclass__ = ABCMeta def __ne__ ( self , other : object ) -> bool : result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : raise NotImplementedError","title":"Atom"},{"location":"reference/dotenv/variables/#descendants","text":"dotenv.variables.Literal dotenv.variables.Variable","title":"Descendants"},{"location":"reference/dotenv/variables/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/variables/#resolve","text":"def resolve ( self , env : Mapping [ str , Optional [ str ]] ) -> str View Source def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : raise NotImplementedError","title":"resolve"},{"location":"reference/dotenv/variables/#literal","text":"class Literal ( value : str ) View Source class Literal ( Atom ) : def __init__ ( self , value : str ) -> None : self . value = value def __repr__ ( self ) -> str : return \"Literal(value={})\" . format ( self . value ) def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , self . __class__ ) : return NotImplemented return self . value == other . value def __hash__ ( self ) -> int : return hash (( self . __class__ , self . value )) def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : return self . value","title":"Literal"},{"location":"reference/dotenv/variables/#ancestors-in-mro","text":"dotenv.variables.Atom","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/variables/#methods_1","text":"","title":"Methods"},{"location":"reference/dotenv/variables/#resolve_1","text":"def resolve ( self , env : Mapping [ str , Optional [ str ]] ) -> str View Source def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : return self . value","title":"resolve"},{"location":"reference/dotenv/variables/#variable","text":"class Variable ( name : str , default : Optional [ str ] ) View Source class Variable ( Atom ) : def __init__ ( self , name : str , default : Optional [ str ] ) -> None : self . name = name self . default = default def __repr__ ( self ) -> str : return \"Variable(name={}, default={})\" . format ( self . name , self . default ) def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , self . __class__ ) : return NotImplemented return ( self . name , self . default ) == ( other . name , other . default ) def __hash__ ( self ) -> int : return hash (( self . __class__ , self . name , self . default )) def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\"","title":"Variable"},{"location":"reference/dotenv/variables/#ancestors-in-mro_1","text":"dotenv.variables.Atom","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/variables/#methods_2","text":"","title":"Methods"},{"location":"reference/dotenv/variables/#resolve_2","text":"def resolve ( self , env : Mapping [ str , Optional [ str ]] ) -> str View Source def resolve ( self , env : Mapping [ str, Optional[str ] ] ) -> str : default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\"","title":"resolve"},{"location":"reference/dotenv/version/","text":"Module dotenv.version None None View Source __version__ = \"0.20.0\"","title":"Version"},{"location":"reference/dotenv/version/#module-dotenvversion","text":"None None View Source __version__ = \"0.20.0\"","title":"Module dotenv.version"}]}